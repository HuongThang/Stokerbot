#include <avr/wdt.h>
#include "web.h"
#include "I2CEEPROM.h"
#include "SPILCD.h"

uint32_t last_rio_event = 0;
uint32_t uptime = 0;
uint16_t timed_events[12*4];

static int8_t dns_state=0;
uint8_t start_web_client=0;
static uint32_t web_client_attempts=0;
static uint32_t web_client_sendok=0;
uint8_t web_client_monitor=0;
uint16_t dnsTimer;

char lines[6][4][21];
uint8_t lcd_timeouts[6];
uint8_t lcd_current_screen = 255;
uint8_t lcd_current_timeleft = 0;
uint8_t lcd_network_timer = 0;

char host[100];
char url[125];

#if SBNG_TARGET == 50
extern bool alarmDetected;
extern uint8_t alarmTimeout;
#endif

void lcd_write_screen(uint8_t screen)
{
	for (uint8_t i=0; i<4; i++)
	{
		LCDsetCursor(i, 0);
		LCDwrite(lines[screen][i], 0);
	}
}

//called every second
void lcd_update()
{
	if (lcd_current_screen == 255)
	{
		printf("First call to lcd_update, starting web client \r\n");
		//first screen update
		if (start_web_client == 0)
		{
			start_web_client = 10;
			lcd_current_screen = 254;
			//waiting for LCD data, callback function sets it to 250 when theres valid data
		}
	} else if (lcd_current_screen == 254)
	{
		if (lcd_network_timer++ > 60)
		{
			printf("Retry LCD get\r\n");
			start_web_client = 10;
			lcd_network_timer=0;
		}
	} else if (lcd_current_screen == 250)
	{
		printf("Web client set screen to 250 \r\n");
		lcd_current_screen = 0;
		lcd_current_timeleft = lcd_timeouts[0];
		lcd_write_screen(0);
	}

	if (lcd_current_screen >= 0 && lcd_current_screen <= 6)
	{
		if (lcd_current_timeleft > 0)
			lcd_current_timeleft--;
		if (lcd_network_timer > 0)
			lcd_network_timer--;

		//regular run
		uint8_t screensDefined = 0;
		for (uint8_t i=0; i<6; i++)
		{
			if (lcd_timeouts[i] > 0)
				screensDefined++;
		}

		printf("Timeout left for %u is %u \r\n", lcd_current_screen, lcd_current_timeleft);

		if (lcd_network_timer == 0
			&&
			(
				(screensDefined == 1 && lcd_current_timeleft < 20)
				||
				(screensDefined == lcd_current_screen+1)
			)
		   )
		   {
				if (start_web_client == 0)
				{
					printf("Requesting new LCD data\r\n");
					start_web_client = 10;
					lcd_network_timer = 30;
				}
		   }

		   if (lcd_current_timeleft == 0)
		   {
				printf("Time to change screen ... \r\n");
				lcd_current_screen++;
				if (lcd_current_screen >= screensDefined) //screens are zero indexed
					lcd_current_screen = 0;
				lcd_write_screen(lcd_current_screen);
				lcd_current_timeleft = lcd_timeouts[lcd_current_screen];
				printf("Changed to screen %u ... \r\n",lcd_current_screen);
		   }
	}
}

//Diverse hjælper funktioner til form... ligger i en seperat fil, da hver fil maks kan være 1 pakke lang
//De er alle gzipped og kan derfor indeholde 0x00
#if SBNG_TARGET == 50
PROGMEM const char alarms_js[] = {
	0x1F, 0x8B, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x85, 0x92, 0x41, 0x4F, 0x83, 0x30,
	0x18, 0x86, 0xCF, 0xE3, 0x57, 0x34, 0xBB, 0x7C, 0x25, 0x2E, 0x61, 0xB4, 0x6C, 0x1E, 0xC4, 0x25,
	0x26, 0x1A, 0x67, 0x62, 0xA2, 0xD9, 0x8C, 0x1E, 0x96, 0x1D, 0x90, 0x16, 0x6D, 0xC2, 0xC0, 0xD0,
	0x9A, 0x1D, 0x8C, 0xFF, 0xDD, 0x02, 0xA3, 0xC8, 0xDA, 0x29, 0x37, 0x78, 0xFA, 0xF4, 0x7B, 0x79,
	0xDB, 0xEC, 0xB3, 0x48, 0x95, 0x28, 0x0B, 0x24, 0xDF, 0xCB, 0xFD, 0x55, 0x9E, 0x54, 0x3B, 0x2C,
	0x98, 0xEF, 0x7D, 0x79, 0x08, 0x65, 0x65, 0xB5, 0x93, 0x2A, 0xA9, 0x14, 0x86, 0x40, 0x72, 0xA5,
	0x44, 0xF1, 0x26, 0x83, 0xA4, 0x5E, 0x02, 0xFE, 0x85, 0x37, 0x62, 0x7B, 0x0C, 0xB1, 0xAA, 0x16,
	0xB1, 0x62, 0x8B, 0xE6, 0x83, 0x94, 0x3C, 0xE7, 0xA9, 0xC2, 0xE3, 0xF5, 0xF8, 0x4C, 0xB0, 0x09,
	0x6A, 0x96, 0xCA, 0x8D, 0x60, 0xDB, 0xCD, 0x74, 0x3B, 0x41, 0xA1, 0x7F, 0x70, 0x02, 0x2D, 0xF4,
	0x12, 0xCF, 0x25, 0x86, 0x27, 0xD0, 0x46, 0xFD, 0x5A, 0x7E, 0xE8, 0x69, 0x21, 0x0C, 0xE4, 0x50,
	0xCB, 0x10, 0x83, 0xC1, 0xC4, 0x81, 0x2F, 0x7B, 0x4C, 0x1D, 0xD8, 0xCC, 0xE2, 0xD8, 0x44, 0x1F,
	0xC4, 0x50, 0x19, 0x86, 0x67, 0x38, 0x8E, 0x4D, 0xB4, 0x4B, 0xDC, 0x42, 0x9B, 0xFB, 0xFA, 0x77,
	0xEE, 0x70, 0xE0, 0xD2, 0xE6, 0x97, 0x0F, 0x88, 0x58, 0x88, 0x74, 0x88, 0x5A, 0x88, 0x76, 0x28,
	0xB2, 0x50, 0x64, 0x36, 0xB4, 0x19, 0xAC, 0x42, 0x53, 0x02, 0x99, 0x39, 0x30, 0xE9, 0xF1, 0xDC,
	0x81, 0x69, 0x8F, 0xCF, 0x1D, 0x38, 0xD2, 0x78, 0xF4, 0x67, 0x87, 0x6D, 0x25, 0x8F, 0xA7, 0x2B,
	0x89, 0xEA, 0x8D, 0x96, 0x77, 0xB7, 0x4B, 0x33, 0x69, 0x6A, 0xF3, 0xFB, 0x87, 0x97, 0xFF, 0x0E,
	0x2B, 0x7D, 0xC5, 0xB0, 0xB2, 0x0E, 0x6B, 0xD6, 0x15, 0xEE, 0x16, 0x6E, 0x2C, 0x61, 0x7E, 0x52,
	0x68, 0xEF, 0x3E, 0x2F, 0xD8, 0x51, 0x80, 0x40, 0x5F, 0x77, 0xCD, 0xD1, 0xE0, 0xF1, 0xBE, 0xBD,
	0x1F, 0x56, 0x27, 0x97, 0x2D, 0x45, 0x03, 0x00, 0x00,'%','E','N','D'
};

PROGMEM const char fmu_js[] = {
	0x1F, 0x8B, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xBD, 0x54, 0xC1, 0x4E, 0xC3, 0x30,
	0x0C, 0xBD, 0xF3, 0x15, 0x51, 0x2E, 0x69, 0xD5, 0x88, 0xB1, 0x01, 0x17, 0xE8, 0x8A, 0xD0, 0x38,
	0xC0, 0x09, 0x09, 0xF8, 0x81, 0x34, 0x49, 0x59, 0xC4, 0x96, 0x4E, 0x8D, 0xDB, 0x01, 0x13, 0xFF,
	0x4E, 0x9C, 0x76, 0x5B, 0x3B, 0x4D, 0x08, 0x71, 0xE0, 0x50, 0x2D, 0xB6, 0xDF, 0xB3, 0x9F, 0x5F,
	0xBB, 0x14, 0xB5, 0x95, 0x60, 0x4A, 0x4B, 0xD4, 0x3A, 0x12, 0xF1, 0x46, 0x95, 0xB2, 0x5E, 0x6A,
	0x0B, 0xA7, 0xEB, 0xCA, 0x80, 0xF6, 0x99, 0xAF, 0x93, 0x62, 0x8B, 0x28, 0x22, 0xE0, 0x96, 0x37,
	0xDC, 0x79, 0xD8, 0x3A, 0x62, 0xA9, 0xB1, 0xAB, 0x1A, 0x08, 0x7C, 0xAC, 0xF4, 0x94, 0xB2, 0x04,
	0x12, 0x46, 0x89, 0x15, 0xCB, 0x10, 0x58, 0x0C, 0x8C, 0xDA, 0x1D, 0x1B, 0xB1, 0xA8, 0x43, 0xA1,
	0xC1, 0xC8, 0x99, 0x4F, 0x3D, 0x65, 0x89, 0x4B, 0x68, 0x46, 0xFB, 0x03, 0xA0, 0x88, 0x04, 0xCF,
	0xB9, 0x8C, 0x37, 0x45, 0xC4, 0x40, 0xBF, 0x03, 0xE3, 0x44, 0x70, 0x92, 0x73, 0x22, 0x87, 0xB0,
	0x79, 0x0F, 0x37, 0x37, 0x4A, 0x69, 0x7B, 0x1C, 0x59, 0x94, 0x95, 0x5F, 0x46, 0x45, 0x9D, 0xE0,
	0xBC, 0xCA, 0x58, 0x7C, 0xED, 0x39, 0xAE, 0xCE, 0x97, 0x06, 0xBB, 0x33, 0x7C, 0x9E, 0x45, 0xA3,
	0xC3, 0x39, 0xBE, 0x0E, 0xB0, 0x11, 0xD2, 0x3C, 0xB2, 0xD7, 0xA8, 0x5C, 0xC1, 0x76, 0x64, 0x80,
	0xF8, 0x18, 0xD3, 0xBB, 0xB5, 0x04, 0xAE, 0xC5, 0x12, 0xE3, 0x9E, 0xF5, 0x42, 0x4B, 0xD0, 0x0A,
	0xD1, 0x31, 0xEE, 0x97, 0xC8, 0x84, 0xA6, 0xA3, 0x16, 0x3F, 0xDC, 0x56, 0x28, 0xE9, 0x74, 0xBF,
	0x2D, 0x4D, 0xA1, 0xCA, 0x52, 0x50, 0xD9, 0xAD, 0x15, 0x8B, 0xF2, 0x95, 0xB4, 0xFE, 0x52, 0xDF,
	0x9C, 0x06, 0x97, 0xD3, 0x91, 0xAF, 0x61, 0x9D, 0x76, 0x42, 0x5D, 0x18, 0xB6, 0x33, 0x3D, 0xF7,
	0x22, 0x70, 0x41, 0x14, 0x3B, 0xE6, 0x92, 0xD3, 0xDB, 0xBB, 0x19, 0x6D, 0xC3, 0x09, 0x86, 0x77,
	0xE6, 0xD5, 0x80, 0x58, 0x74, 0xA9, 0x73, 0x4C, 0xCD, 0xCA, 0xDA, 0x82, 0xAE, 0xDA, 0x86, 0x5E,
	0x67, 0xDB, 0x31, 0x6B, 0x27, 0x8D, 0xBC, 0x9C, 0x81, 0x62, 0xE3, 0x66, 0x73, 0x2D, 0xDF, 0x70,
	0xBB, 0x78, 0x53, 0x69, 0xA8, 0x2B, 0xBF, 0x45, 0x76, 0x76, 0x43, 0x89, 0x6C, 0xF3, 0x84, 0x5E,
	0x51, 0x7A, 0x8C, 0xF0, 0x14, 0xFC, 0xD8, 0x71, 0xA6, 0xD3, 0xFC, 0x27, 0xD2, 0xC0, 0xC4, 0x03,
	0x92, 0xEB, 0x6A, 0x87, 0x2C, 0xB5, 0x2A, 0xAB, 0xA3, 0x66, 0x76, 0x5B, 0x13, 0xAC, 0xFF, 0xD1,
	0xCC, 0x33, 0xB4, 0xEA, 0xB1, 0x06, 0xFF, 0x3A, 0xFA, 0x7E, 0x3E, 0xD8, 0x7D, 0xE2, 0xC0, 0x4D,
	0x4C, 0x5D, 0x04, 0xCF, 0xEF, 0x5F, 0x26, 0x93, 0x2E, 0x71, 0xD9, 0x25, 0xC6, 0xE3, 0x5F, 0xFA,
	0xED, 0xAB, 0x2E, 0x42, 0x41, 0xDD, 0x57, 0x77, 0x20, 0x11, 0x7F, 0x5B, 0x95, 0x43, 0x8E, 0xEE,
	0x73, 0xB6, 0x23, 0xD8, 0xFF, 0xBF, 0x48, 0x99, 0x7B, 0xB0, 0xE4, 0xCD, 0x91, 0xEB, 0x22, 0x30,
	0xF2, 0xF2, 0x7D, 0x7F, 0x63, 0x88, 0xFD, 0x8D, 0x81, 0x47, 0xFC, 0x2F, 0x6D, 0x35, 0xCA, 0x38,
	0x61, 0xC3, 0x1B, 0x24, 0x6C, 0xF3, 0x0D, 0x18, 0x47, 0x52, 0xDD, 0xBA, 0x04, 0x00, 0x00,
	'%','E','N','D'
};

PROGMEM const char fmu2_js[] = {
	0x1F, 0x8B, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x8D, 0x92, 0x3B, 0x4F, 0xC3, 0x30,
	0x10, 0xC7, 0xE7, 0x46, 0xCA, 0x77, 0x38, 0x65, 0x20, 0x8E, 0x92, 0x36, 0xB4, 0x8C, 0x79, 0x48,
	0x80, 0x78, 0x2D, 0x30, 0x80, 0x58, 0xAA, 0x0E, 0x6E, 0x72, 0x49, 0x4C, 0x63, 0xBB, 0xB2, 0xDD,
	0x76, 0xA8, 0xF8, 0xEE, 0xD8, 0x69, 0x10, 0x65, 0xEB, 0x72, 0xB6, 0xEF, 0xFE, 0xBF, 0x7B, 0xC9,
	0xCD, 0x4E, 0x54, 0x86, 0x49, 0x01, 0x8D, 0x54, 0x5C, 0x1B, 0xAA, 0x0C, 0xD9, 0xA9, 0x3E, 0x3A,
	0xD6, 0x07, 0x12, 0xE6, 0xCE, 0x07, 0x1C, 0x4D, 0x27, 0xEB, 0x22, 0x78, 0x7A, 0xF8, 0x08, 0x80,
	0x0E, 0xE2, 0x22, 0x08, 0x63, 0xAB, 0x8A, 0xC3, 0xA0, 0x0C, 0xA3, 0x6F, 0xDF, 0xF3, 0xBD, 0xE6,
	0x37, 0x8D, 0xD6, 0xD8, 0x63, 0x65, 0x88, 0xA0, 0x1C, 0x13, 0x38, 0x3D, 0xB0, 0x4E, 0xA0, 0xEA,
	0xA4, 0xD4, 0x18, 0xF9, 0xDE, 0xD1, 0xF7, 0x26, 0xD6, 0xAD, 0x07, 0x45, 0x94, 0x39, 0x78, 0xC2,
	0x1A, 0x20, 0x27, 0x01, 0x14, 0x05, 0xCC, 0x23, 0x90, 0x5B, 0x43, 0xC2, 0x30, 0x81, 0x70, 0xEA,
	0xCC, 0xFD, 0x29, 0x24, 0x05, 0x86, 0x23, 0x60, 0x1B, 0x03, 0xB2, 0xA7, 0x0A, 0x58, 0x71, 0x9D,
	0x01, 0xCB, 0x35, 0x0A, 0x2D, 0x95, 0x9E, 0xF5, 0x28, 0x5A, 0xD3, 0x59, 0x4F, 0x1C, 0xDB, 0x52,
	0x93, 0x89, 0xCB, 0x33, 0xC6, 0x96, 0x6C, 0xB5, 0xBC, 0x5E, 0x9D, 0xB7, 0x74, 0x16, 0x98, 0xAF,
	0xC6, 0xC4, 0x2E, 0x4A, 0xDC, 0xFD, 0xFF, 0x54, 0x1C, 0xC5, 0x8E, 0x70, 0xFA, 0x25, 0x55, 0xC2,
	0x99, 0x90, 0x2A, 0x02, 0x3B, 0xC6, 0xB0, 0xA2, 0x9A, 0xED, 0x81, 0xD9, 0xED, 0x74, 0x48, 0x6B,
	0x54, 0x41, 0x69, 0x64, 0x2F, 0xDB, 0x59, 0xBD, 0x81, 0xCF, 0xBB, 0x1B, 0x98, 0xC2, 0x23, 0x53,
	0xFC, 0x40, 0x15, 0xC2, 0x62, 0x36, 0x5F, 0xE4, 0x6B, 0x55, 0xE6, 0x14, 0x3A, 0x85, 0x4D, 0x11,
	0xA4, 0x41, 0xF9, 0x2C, 0x39, 0xE6, 0x29, 0x2D, 0xAF, 0xC4, 0x5A, 0x6F, 0xB3, 0x73, 0xFB, 0xA7,
	0xD2, 0x68, 0x0C, 0x13, 0xAD, 0x4E, 0x5B, 0x14, 0xA8, 0x68, 0x6F, 0xB1, 0xF7, 0xD1, 0x95, 0x5F,
	0x48, 0x0A, 0x34, 0x96, 0x7A, 0x45, 0x73, 0x90, 0x6A, 0x73, 0x71, 0x3D, 0x26, 0x2D, 0xF4, 0x92,
	0xBE, 0x5D, 0x0C, 0xD0, 0x9E, 0x2A, 0x6E, 0x99, 0x5B, 0x77, 0x6A, 0x87, 0xE5, 0xA9, 0xDD, 0x4E,
	0x39, 0x4C, 0x5D, 0xA1, 0x30, 0xA8, 0xEC, 0x6F, 0xC9, 0x60, 0xD8, 0xED, 0x0F, 0xDF, 0xD3, 0x33,
	0x29, 0x77, 0x02, 0x00, 0x00,'%','E','N','D'
};

PROGMEM const char loader_js[] = {
	0x1F, 0x8B, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x6D, 0x8F, 0x4D, 0x0E, 0x82, 0x30,
	0x10, 0x85, 0xF7, 0x3D, 0x45, 0xD3, 0x4D, 0x21, 0x26, 0x34, 0x71, 0x2B, 0xE5, 0x24, 0x6E, 0x9A,
	0x3A, 0x84, 0x62, 0x29, 0xD8, 0x99, 0xAA, 0xC4, 0x78, 0x77, 0x4B, 0x88, 0x09, 0x06, 0x67, 0xF9,
	0xCD, 0xCB, 0xFB, 0x69, 0x53, 0xB0, 0xE4, 0xC6, 0xC0, 0x23, 0xDC, 0x92, 0x8B, 0x50, 0xF4, 0x38,
	0x19, 0xEA, 0x4A, 0xFE, 0x62, 0x3C, 0xDF, 0x65, 0xB4, 0x69, 0x80, 0x40, 0xD5, 0x23, 0x3A, 0x82,
	0x42, 0xD6, 0x68, 0xA3, 0x9B, 0x88, 0xD3, 0x3C, 0x81, 0x16, 0x04, 0x4F, 0x52, 0xBD, 0xB9, 0x9B,
	0x95, 0x0A, 0x8E, 0xD1, 0x6A, 0x21, 0x0F, 0xAB, 0xC7, 0x41, 0x8A, 0xA6, 0x3E, 0xAB, 0xF5, 0xD7,
	0xC8, 0xF2, 0xC4, 0xDE, 0x8C, 0x7D, 0x63, 0x84, 0x6A, 0x87, 0x54, 0xF5, 0x28, 0x32, 0xFE, 0x61,
	0xC7, 0x1D, 0x34, 0xDE, 0x21, 0xFD, 0xA1, 0x26, 0x0E, 0xB8, 0xC3, 0xB8, 0x11, 0xEF, 0xCA, 0x7B,
	0x17, 0xAE, 0x79, 0xA8, 0xD7, 0x02, 0x69, 0xF6, 0x80, 0x1D, 0x40, 0x2E, 0xBD, 0xD9, 0x62, 0x11,
	0x05, 0xEF, 0x22, 0xB4, 0x3A, 0x3B, 0x2D, 0x92, 0x6A, 0x21, 0x6A, 0x29, 0xFF, 0x01, 0xBF, 0x04,
	0x2C, 0xFA, 0x29, 0x01, 0x00, 0x00,'%','E','N','D'
};

PROGMEM const char style_css[] = {
	0x1F, 0x8B, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xD5, 0x56, 0xC9, 0x6E, 0xDB, 0x30,
	0x10, 0x3D, 0x37, 0x80, 0xFF, 0x81, 0x48, 0xCE, 0x0A, 0x24, 0x2A, 0x96, 0x5D, 0xF9, 0xD4, 0x43,
	0xD3, 0x4B, 0x5B, 0x14, 0x28, 0xFA, 0x01, 0x94, 0x48, 0x49, 0x4C, 0x28, 0x8E, 0x41, 0xD1, 0xB5,
	0xDD, 0x22, 0xFF, 0x5E, 0x6A, 0xDF, 0x68, 0xC7, 0x49, 0x81, 0x22, 0xA5, 0x2E, 0xF6, 0x70, 0x38,
	0xC3, 0xF7, 0x66, 0x63, 0x04, 0xF4, 0x88, 0x7E, 0x2F, 0xAE, 0xDE, 0x45, 0x24, 0x7E, 0x4C, 0x15,
	0xEC, 0x24, 0x75, 0x62, 0x10, 0xA0, 0x42, 0x74, 0xF3, 0xF1, 0xFD, 0x3D, 0xBE, 0x0F, 0x36, 0x66,
	0x33, 0x27, 0x2A, 0xE5, 0x32, 0x44, 0x6E, 0xF5, 0x87, 0x4B, 0x67, 0xCF, 0xA9, 0xCE, 0x42, 0xE4,
	0xB9, 0xAE, 0xBB, 0x3D, 0x94, 0x42, 0xCD, 0x0E, 0xDA, 0x21, 0x82, 0xA7, 0x46, 0x2B, 0x66, 0x52,
	0x33, 0x65, 0xA4, 0x4F, 0x8B, 0xAB, 0xC5, 0xD5, 0x4D, 0x0C, 0x52, 0x13, 0x2E, 0x99, 0xAA, 0xFC,
	0xD4, 0xA6, 0x1C, 0xC1, 0x12, 0x1D, 0x22, 0xB2, 0xD3, 0xD0, 0xDB, 0x77, 0x14, 0x4F, 0xB3, 0x81,
	0x74, 0x68, 0xB3, 0xD4, 0x2F, 0x65, 0x53, 0xC7, 0xB5, 0x8B, 0x8C, 0x11, 0xDA, 0xD8, 0xB7, 0xE0,
	0x48, 0xAA, 0x55, 0x9E, 0x6E, 0x25, 0x6E, 0xB5, 0x4A, 0x49, 0x62, 0x2E, 0xE7, 0x24, 0x24, 0xE7,
	0xE2, 0x18, 0xA2, 0xEB, 0x2F, 0x47, 0xC5, 0x09, 0x45, 0xDF, 0x14, 0x5C, 0x77, 0x9B, 0x05, 0xFF,
	0xC5, 0x42, 0xE4, 0x37, 0x38, 0x33, 0x56, 0xDF, 0xD1, 0x6B, 0x81, 0x6F, 0x09, 0xA5, 0x5C, 0xA6,
	0x4E, 0x04, 0x5A, 0x43, 0x1E, 0xA2, 0xE5, 0x58, 0x5C, 0xE3, 0xF4, 0x27, 0xCA, 0x0D, 0xD0, 0xA9,
	0x58, 0xC3, 0xD6, 0x08, 0x97, 0x03, 0x46, 0x29, 0x8B, 0x41, 0x11, 0xCD, 0xC1, 0x50, 0x20, 0x41,
	0xB2, 0x29, 0x62, 0x52, 0x61, 0x7E, 0x3D, 0x2C, 0x6F, 0x7D, 0x89, 0xB3, 0x9C, 0xC9, 0x9D, 0xF7,
	0x3C, 0xBB, 0x89, 0x00, 0xA2, 0xFB, 0x50, 0x4D, 0x99, 0x09, 0x6C, 0xCC, 0xB8, 0x97, 0xD2, 0x12,
	0x0C, 0xC2, 0x5D, 0xDF, 0x67, 0x8C, 0x7D, 0xED, 0x96, 0xDF, 0x8B, 0xB0, 0xDF, 0x5D, 0x8E, 0x9D,
	0x84, 0x19, 0xFC, 0x6C, 0x32, 0x6C, 0xC6, 0x76, 0xAF, 0x88, 0xDF, 0x18, 0x49, 0xF8, 0x1F, 0x92,
	0x84, 0xAD, 0x24, 0xB1, 0x38, 0xC1, 0x89, 0xDF, 0x29, 0xF2, 0x9C, 0xA4, 0x2C, 0x82, 0xC3, 0xDB,
	0xE1, 0xE9, 0x76, 0xAB, 0xE0, 0x81, 0xC5, 0x7A, 0xD8, 0x9C, 0x5A, 0x27, 0xB8, 0x29, 0xC5, 0x51,
	0xCF, 0x72, 0xE7, 0x0D, 0x6B, 0x28, 0xAA, 0xEC, 0x7B, 0xCB, 0xDE, 0x41, 0xE6, 0x5D, 0x14, 0x82,
	0x0F, 0x26, 0x02, 0x02, 0x7D, 0x25, 0x4A, 0xC1, 0x7E, 0x1A, 0x04, 0xDC, 0x04, 0xA1, 0x12, 0xED,
	0x9B, 0x0E, 0x24, 0x41, 0xE5, 0x44, 0x8C, 0xBA, 0xF3, 0xC0, 0x29, 0x3E, 0xD7, 0x18, 0x9A, 0xD0,
	0x8E, 0xD1, 0x4D, 0x1A, 0xD8, 0x8B, 0x31, 0xE3, 0xA1, 0x7B, 0xFF, 0x02, 0xF7, 0xD8, 0xEA, 0xDE,
	0x7D, 0xA5, 0xFB, 0xE1, 0x38, 0xC8, 0xCD, 0xB8, 0x39, 0x95, 0x61, 0xF7, 0xD5, 0xEA, 0x54, 0xCB,
	0xBC, 0x1E, 0xDD, 0xF5, 0xAE, 0x5A, 0xF3, 0xF8, 0x7C, 0x62, 0x60, 0x9C, 0x91, 0x59, 0x7D, 0xF8,
	0xF5, 0x7D, 0x85, 0x19, 0x70, 0x4E, 0x37, 0x1C, 0xD6, 0x76, 0x68, 0x73, 0x60, 0x23, 0xBD, 0x93,
	0xD0, 0x6C, 0x05, 0x80, 0xAD, 0x83, 0x06, 0xDB, 0x07, 0x0D, 0xB6, 0x15, 0x01, 0x5E, 0xCE, 0x47,
	0xF7, 0xC3, 0xAE, 0xD0, 0x3C, 0x39, 0x8E, 0xE9, 0x39, 0xD5, 0x43, 0xCE, 0xF6, 0x04, 0x72, 0x82,
	0xD5, 0xB3, 0x87, 0x6E, 0x23, 0x9E, 0x1A, 0x26, 0x1F, 0xCF, 0x55, 0x4C, 0xD7, 0x97, 0xF4, 0xF3,
	0x7D, 0xA9, 0xBE, 0xBE, 0xA5, 0x2D, 0x75, 0xF7, 0xA9, 0xF5, 0x12, 0x00, 0x7D, 0xFA, 0xFD, 0x40,
	0x83, 0xF2, 0xDB, 0x5C, 0x90, 0x24, 0x9F, 0x77, 0x31, 0xA7, 0x04, 0x7D, 0x27, 0xB2, 0x40, 0x3F,
	0x24, 0x8F, 0x81, 0xB2, 0x59, 0xC2, 0x78, 0xF6, 0x77, 0x43, 0xF0, 0xB7, 0xEF, 0x86, 0x60, 0x1E,
	0xCD, 0x4A, 0x7D, 0x0A, 0x72, 0x1C, 0x18, 0x1C, 0x94, 0xDF, 0xF3, 0x4C, 0xB6, 0x87, 0x2D, 0x5C,
	0x06, 0xD5, 0xEA, 0x42, 0x58, 0xB0, 0x2D, 0x31, 0x26, 0x60, 0xAC, 0xD4, 0x95, 0x9D, 0x85, 0x8B,
	0xFA, 0x5C, 0x2C, 0x18, 0x69, 0xCE, 0x94, 0xBF, 0x42, 0x64, 0x98, 0xC9, 0xDA, 0xDD, 0x84, 0x33,
	0x41, 0x0B, 0x56, 0x97, 0x6A, 0x04, 0xCA, 0xBC, 0x7D, 0xBA, 0xF0, 0xF8, 0xD1, 0x2A, 0x58, 0xAF,
	0x36, 0xFD, 0x46, 0xA1, 0x8F, 0xC2, 0x58, 0x2F, 0x40, 0x70, 0x3A, 0x10, 0xB7, 0x4F, 0xC7, 0xDE,
	0xA7, 0x60, 0x29, 0x93, 0xF4, 0x54, 0xD8, 0x67, 0x76, 0xDB, 0x8D, 0xD5, 0xDA, 0xF3, 0x97, 0xDE,
	0x0B, 0x1D, 0x76, 0x4C, 0xC4, 0x4B, 0x93, 0x4D, 0x91, 0xB5, 0xA4, 0x6D, 0x29, 0x10, 0x58, 0x33,
	0x20, 0xB0, 0xD5, 0xF3, 0x80, 0x4C, 0x2E, 0x13, 0x38, 0x33, 0x66, 0xFF, 0x63, 0x68, 0xBA, 0x7C,
	0xF9, 0x8E, 0x52, 0xAB, 0x07, 0x33, 0x1F, 0x6E, 0xF5, 0x91, 0x32, 0x79, 0xED, 0x47, 0x9E, 0xFE,
	0x00, 0x5B, 0x52, 0xAE, 0x47, 0x00, 0x0D, 0x00, 0x00,'%','E','N','D'
};

PROGMEM const char alarms_htm[] = {
	0x1F, 0x8B, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x5D, 0x90, 0xCF, 0x0B, 0x82, 0x30,
	0x14, 0xC7, 0xCF, 0xED, 0xAF, 0xD8, 0x4D, 0xC5, 0x68, 0xD8, 0x29, 0x70, 0x0E, 0x42, 0x3A, 0x74,
	0x2A, 0x54, 0xBA, 0x4F, 0xB7, 0xB0, 0x50, 0x27, 0x6F, 0x9B, 0xD2, 0x7F, 0x9F, 0xBA, 0x4A, 0xE8,
	0xF0, 0xE0, 0x7D, 0xBE, 0xEF, 0xF7, 0xA3, 0x79, 0x9A, 0x9D, 0xAF, 0x05, 0xCE, 0xB3, 0x34, 0xF1,
	0x48, 0xA3, 0xB8, 0x90, 0xB0, 0x7B, 0x6A, 0x8F, 0x51, 0xE2, 0x22, 0x0C, 0x51, 0x5D, 0xC1, 0xA3,
	0x37, 0x0C, 0xB5, 0xB2, 0xB3, 0xFE, 0x7E, 0x1B, 0x05, 0x31, 0x42, 0x62, 0xF4, 0x3D, 0x6A, 0x78,
	0xD9, 0x48, 0x5C, 0x2A, 0x98, 0x8A, 0x92, 0x88, 0x79, 0x53, 0xC0, 0xE9, 0xB5, 0xE4, 0x82, 0x51,
	0x03, 0x93, 0x09, 0x96, 0x2B, 0x0B, 0x95, 0xA4, 0xC4, 0x88, 0x05, 0x8B, 0x57, 0xBF, 0xC2, 0x8D,
	0x37, 0x76, 0xA5, 0x8B, 0x35, 0xBD, 0x35, 0x7F, 0x88, 0xB5, 0xE1, 0x66, 0xCD, 0xC9, 0xE4, 0x20,
	0x41, 0xAF, 0x7C, 0xEA, 0xE6, 0x25, 0x1C, 0x92, 0x79, 0x22, 0x71, 0xD3, 0xE7, 0x65, 0xEE, 0x0A,
	0xB0, 0x3F, 0x70, 0xC0, 0xBC, 0xE1, 0xD0, 0x26, 0x51, 0xEC, 0x1C, 0x9A, 0x1C, 0x3E, 0x5E, 0x18,
	0x06, 0x68, 0xA3, 0x6B, 0x35, 0x1E, 0x67, 0xF2, 0x17, 0xED, 0x77, 0x1D, 0x59, 0xCE, 0x5B, 0x1A,
	0x21, 0x4A, 0xBE, 0x4F, 0x78, 0x03, 0xE5, 0xB9, 0x85, 0x93, 0x31, 0x01, 0x00, 0x00,
	'%','E','N','D'
};





#else



PROGMEM const char webclient_htm[] = {
	0x3C, 0x53, 0x43, 0x52, 0x49, 0x50, 0x54, 0x20, 0x53, 0x52, 0x43, 0x3D, 0x27, 0x2F, 0x6C, 0x6F,
	0x61, 0x64, 0x65, 0x72, 0x2E, 0x6A, 0x73, 0x27, 0x3E, 0x3C, 0x2F, 0x53, 0x43, 0x52, 0x49, 0x50,
	0x54, 0x3E, 0x0A, 0x3C, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x3E, 0x0A, 0x6D, 0x65, 0x6E, 0x75,
	0x28, 0x32, 0x2C, 0x31, 0x29, 0x3B, 0x0A, 0x66, 0x6F, 0x72, 0x6D, 0x73, 0x74, 0x61, 0x72, 0x74,
	0x28, 0x27, 0x2F, 0x73, 0x65, 0x74, 0x74, 0x69, 0x6E, 0x67, 0x73, 0x2F, 0x77, 0x65, 0x62, 0x63,
	0x6C, 0x69, 0x65, 0x6E, 0x74, 0x27, 0x29, 0x3B, 0x0A, 0x64, 0x77, 0x28, 0x27, 0x3C, 0x62, 0x72,
	0x3E, 0x44, 0x61, 0x74, 0x61, 0x20, 0x69, 0x73, 0x20, 0x73, 0x65, 0x6E, 0x74, 0x20, 0x65, 0x76,
	0x65, 0x72, 0x79, 0x20, 0x27, 0x29, 0x3B, 0x0A, 0x73, 0x65, 0x6C, 0x73, 0x28, 0x22, 0x69, 0x6E,
	0x74, 0x65, 0x72, 0x76, 0x61, 0x6C, 0x22, 0x29, 0x3B, 0x0A, 0x6F, 0x70, 0x74, 0x28, 0x22, 0x33,
	0x22, 0x2C, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6C, 0x2C, 0x20, 0x22, 0x33, 0x30,
	0x20, 0x73, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x73, 0x22, 0x29, 0x3B, 0x0A, 0x6F, 0x70, 0x74, 0x28,
	0x22, 0x36, 0x22, 0x2C, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6C, 0x2C, 0x20, 0x22,
	0x6D, 0x69, 0x6E, 0x75, 0x74, 0x65, 0x22, 0x29, 0x3B, 0x0A, 0x6F, 0x70, 0x74, 0x28, 0x22, 0x33,
	0x30, 0x22, 0x2C, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6C, 0x2C, 0x20, 0x22, 0x35,
	0x20, 0x6D, 0x69, 0x6E, 0x75, 0x74, 0x74, 0x65, 0x73, 0x22, 0x29, 0x3B, 0x0A, 0x6F, 0x70, 0x74,
	0x28, 0x22, 0x39, 0x30, 0x22, 0x2C, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6C, 0x2C,
	0x20, 0x22, 0x31, 0x35, 0x20, 0x6D, 0x69, 0x6E, 0x75, 0x74, 0x74, 0x65, 0x73, 0x22, 0x29, 0x3B,
	0x0A, 0x6F, 0x70, 0x74, 0x28, 0x22, 0x31, 0x38, 0x30, 0x22, 0x2C, 0x20, 0x69, 0x6E, 0x74, 0x65,
	0x72, 0x76, 0x61, 0x6C, 0x2C, 0x20, 0x22, 0x33, 0x30, 0x20, 0x6D, 0x69, 0x6E, 0x75, 0x74, 0x74,
	0x65, 0x73, 0x22, 0x29, 0x3B, 0x0A, 0x6F, 0x70, 0x74, 0x28, 0x22, 0x30, 0x22, 0x2C, 0x20, 0x69,
	0x6E, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6C, 0x2C, 0x20, 0x22, 0x4E, 0x65, 0x76, 0x65, 0x72, 0x20,
	0x28, 0x44, 0x69, 0x73, 0x61, 0x62, 0x6C, 0x65, 0x64, 0x29, 0x22, 0x29, 0x3B, 0x0A, 0x73, 0x65,
	0x6C, 0x65, 0x28, 0x29, 0x3B, 0x0A, 0x64, 0x77, 0x28, 0x27, 0x3C, 0x62, 0x72, 0x3E, 0x54, 0x6F,
	0x20, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x27, 0x29, 0x3B, 0x66, 0x28, 0x27, 0x74, 0x65,
	0x78, 0x74, 0x27, 0x2C, 0x27, 0x68, 0x6F, 0x73, 0x74, 0x27, 0x2C, 0x68, 0x6F, 0x73, 0x74, 0x2C,
	0x35, 0x30, 0x29, 0x3B, 0x64, 0x77, 0x28, 0x27, 0x20, 0x2F, 0x20, 0x27, 0x29, 0x3B, 0x66, 0x28,
	0x27, 0x74, 0x65, 0x78, 0x74, 0x27, 0x2C, 0x27, 0x75, 0x72, 0x6C, 0x27, 0x2C, 0x75, 0x72, 0x6C,
	0x2C, 0x35, 0x30, 0x29, 0x3B, 0x64, 0x77, 0x28, 0x27, 0x20, 0x26, 0x69, 0x64, 0x3D, 0x78, 0x79,
	0x7A, 0x26, 0x73, 0x65, 0x6E, 0x73, 0x6F, 0x72, 0x2E, 0x2E, 0x6E, 0x3D, 0x76, 0x61, 0x6C, 0x75,
	0x65, 0x2E, 0x2E, 0x6E, 0x3C, 0x62, 0x72, 0x3E, 0x27, 0x29, 0x3B, 0x0A, 0x66, 0x6F, 0x72, 0x6D,
	0x65, 0x6E, 0x64, 0x28, 0x29, 0x3B, 0x0A, 0x3C, 0x2F, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x3E,
	0x0A, 0x0A, 0x54, 0x68, 0x65, 0x20, 0x68, 0x6F, 0x73, 0x74, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x61,
	0x6E, 0x64, 0x20, 0x75, 0x72, 0x6C, 0x20, 0x6D, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x65,
	0x6E, 0x74, 0x65, 0x72, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20,
	0x32, 0x20, 0x73, 0x65, 0x70, 0x65, 0x72, 0x61, 0x74, 0x65, 0x20, 0x66, 0x69, 0x65, 0x6C, 0x64,
	0x73, 0x2E, 0x3C, 0x62, 0x72, 0x3E, 0x0A, 0x48, 0x6F, 0x73, 0x74, 0x6E, 0x61, 0x6D, 0x65, 0x20,
	0x69, 0x73, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x20, 0x44, 0x4E, 0x53, 0x20, 0x6C,
	0x6F, 0x6F, 0x6B, 0x75, 0x70, 0x2C, 0x20, 0x73, 0x6F, 0x20, 0x69, 0x74, 0x20, 0x6D, 0x75, 0x73,
	0x74, 0x20, 0x62, 0x65, 0x20, 0x61, 0x20, 0x76, 0x61, 0x6C, 0x69, 0x64, 0x20, 0x64, 0x6F, 0x6D,
	0x61, 0x69, 0x6E, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x6F, 0x72, 0x20, 0x61, 0x6E, 0x20, 0x49,
	0x50, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x2E, 0x3C, 0x62, 0x72, 0x3E, 0x0A, 0x54,
	0x68, 0x65, 0x20, 0x75, 0x72, 0x6C, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x70,
	0x6F, 0x73, 0x74, 0x66, 0x69, 0x78, 0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x26, 0x69,
	0x64, 0x3D, 0x78, 0x79, 0x7A, 0x26, 0x41, 0x44, 0x43, 0x30, 0x3D, 0x31, 0x30, 0x26, 0x41, 0x44,
	0x43, 0x31, 0x3D, 0x31, 0x32, 0x20, 0x65, 0x74, 0x63, 0x2E, 0x3C, 0x62, 0x72, 0x3E, 0x0A, 0x53,
	0x6F, 0x20, 0x6D, 0x61, 0x6B, 0x65, 0x20, 0x73, 0x75, 0x72, 0x65, 0x20, 0x69, 0x74, 0x20, 0x61,
	0x6C, 0x72, 0x65, 0x61, 0x64, 0x79, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x73, 0x20,
	0x3F, 0x73, 0x6F, 0x6D, 0x65, 0x74, 0x68, 0x69, 0x6E, 0x67, 0x3D, 0x76, 0x61, 0x6C, 0x3C, 0x62,
	0x72, 0x3E, 0x0A, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20,
	0x73, 0x74, 0x6F, 0x6B, 0x65, 0x72, 0x6C, 0x6F, 0x67, 0x2E, 0x64, 0x6B, 0x20, 0x2F, 0x20, 0x69,
	0x6E, 0x63, 0x6F, 0x6D, 0x69, 0x6E, 0x67, 0x2E, 0x70, 0x68, 0x70, 0x3F, 0x76, 0x3D, 0x31, 0x20,
	0x3C, 0x62, 0x72, 0x3E,'%','E','N','D'
};


PROGMEM const char alarms_htm[] = {
	0x1F, 0x8B, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x5D, 0x90, 0xCF, 0x0B, 0x82, 0x30,
	0x14, 0xC7, 0xCF, 0xED, 0xAF, 0xD8, 0x4D, 0xC5, 0x68, 0xD8, 0x29, 0x70, 0x0E, 0x42, 0x3A, 0x74,
	0x2A, 0x54, 0xBA, 0x4F, 0xB7, 0xB0, 0x50, 0x27, 0x6F, 0x9B, 0xD2, 0x7F, 0x9F, 0xBA, 0x4A, 0xE8,
	0xF0, 0xE0, 0x7D, 0xBE, 0xEF, 0xF7, 0xA3, 0x79, 0x9A, 0x9D, 0xAF, 0x05, 0xCE, 0xB3, 0x34, 0xF1,
	0x48, 0xA3, 0xB8, 0x90, 0xB0, 0x7B, 0x6A, 0x8F, 0x51, 0xE2, 0x22, 0x0C, 0x51, 0x5D, 0xC1, 0xA3,
	0x37, 0x0C, 0xB5, 0xB2, 0xB3, 0xFE, 0x7E, 0x1B, 0x05, 0x31, 0x42, 0x62, 0xF4, 0x3D, 0x6A, 0x78,
	0xD9, 0x48, 0x5C, 0x2A, 0x98, 0x8A, 0x92, 0x88, 0x79, 0x53, 0xC0, 0xE9, 0xB5, 0xE4, 0x82, 0x51,
	0x03, 0x93, 0x09, 0x96, 0x2B, 0x0B, 0x95, 0xA4, 0xC4, 0x88, 0x05, 0x8B, 0x57, 0xBF, 0xC2, 0x8D,
	0x37, 0x76, 0xA5, 0x8B, 0x35, 0xBD, 0x35, 0x7F, 0x88, 0xB5, 0xE1, 0x66, 0xCD, 0xC9, 0xE4, 0x20,
	0x41, 0xAF, 0x7C, 0xEA, 0xE6, 0x25, 0x1C, 0x92, 0x79, 0x22, 0x71, 0xD3, 0xE7, 0x65, 0xEE, 0x0A,
	0xB0, 0x3F, 0x70, 0xC0, 0xBC, 0xE1, 0xD0, 0x26, 0x51, 0xEC, 0x1C, 0x9A, 0x1C, 0x3E, 0x5E, 0x18,
	0x06, 0x68, 0xA3, 0x6B, 0x35, 0x1E, 0x67, 0xF2, 0x17, 0xED, 0x77, 0x1D, 0x59, 0xCE, 0x5B, 0x1A,
	0x21, 0x4A, 0xBE, 0x4F, 0x78, 0x03, 0xE5, 0xB9, 0x85, 0x93, 0x31, 0x01, 0x00, 0x00,
	'%','E','N','D'
};

PROGMEM const char alarms_js[] = {
	0x1F, 0x8B, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x75, 0x92, 0x5F, 0x0B, 0x82, 0x30,
	0x14, 0xC5, 0xDF, 0xFD, 0x14, 0x71, 0x9F, 0x26, 0x09, 0xEA, 0xB4, 0x5E, 0xB4, 0x20, 0x28, 0x2A,
	0x08, 0x8A, 0x8A, 0x7A, 0x10, 0x1F, 0x96, 0xCE, 0x0A, 0x4C, 0xC3, 0x2D, 0x7A, 0x88, 0xBE, 0x7B,
	0xF3, 0x5F, 0x34, 0xD3, 0xC7, 0x9D, 0xF3, 0xBB, 0xBB, 0xE7, 0xB0, 0x45, 0x8F, 0x24, 0xE0, 0xD7,
	0x34, 0xE9, 0xB1, 0x4B, 0xFA, 0x9C, 0xC4, 0x24, 0xBB, 0x21, 0xA2, 0xBE, 0xA2, 0x34, 0xBB, 0x31,
	0x4E, 0x32, 0x8E, 0x40, 0x67, 0x94, 0xF3, 0x6B, 0x72, 0x66, 0x3A, 0xC9, 0x5D, 0x50, 0x9D, 0xF0,
	0x89, 0xC0, 0xE5, 0xD9, 0xD8, 0xE5, 0xE1, 0x58, 0x1C, 0x19, 0xA3, 0x31, 0x0D, 0x04, 0xB9, 0x83,
	0x3E, 0xD1, 0x0A, 0x88, 0x79, 0xC4, 0xF7, 0x0C, 0x5F, 0x33, 0x2B, 0x58, 0x17, 0x64, 0x4D, 0xD3,
	0x98, 0x21, 0xD8, 0x0B, 0x54, 0x75, 0xD2, 0xBB, 0x98, 0x32, 0xE1, 0x67, 0xC6, 0xF4, 0x35, 0x70,
	0xA1, 0x72, 0x70, 0xD3, 0x19, 0xD5, 0x8E, 0xD5, 0x74, 0xAA, 0x9B, 0x29, 0xFA, 0x5F, 0xC8, 0x23,
	0x04, 0x07, 0x39, 0x19, 0xF6, 0x35, 0xDC, 0x95, 0x6C, 0xFA, 0x4D, 0x66, 0xFE, 0x4C, 0x58, 0x45,
	0x97, 0x5C, 0xC5, 0xB2, 0x8A, 0x4B, 0xD5, 0x92, 0x55, 0xAB, 0x54, 0x6D, 0x59, 0xB5, 0x3B, 0x33,
	0x96, 0xAB, 0x37, 0xAD, 0xAB, 0x6D, 0x51, 0x6F, 0xB1, 0x9C, 0x2F, 0xAA, 0xEE, 0x46, 0xC3, 0x5A,
	0xAD, 0x8F, 0xDD, 0xDD, 0x83, 0x13, 0x82, 0xAD, 0xDC, 0x7D, 0x50, 0x34, 0x51, 0xDA, 0xC8, 0x99,
	0x4C, 0x0E, 0x5B, 0xDF, 0x2F, 0xFF, 0x19, 0x34, 0x09, 0xA5, 0x65, 0xBA, 0xF8, 0x0C, 0xA0, 0xBE,
	0x1D, 0xE5, 0x03, 0xEE, 0x46, 0x9B, 0x8B, 0x4D, 0x02, 0x00, 0x00,'%','E','N','D'
};

PROGMEM const char fmu_js[] = {
	0x1F, 0x8B, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xBD, 0x54, 0xC1, 0x4E, 0xC3, 0x30,
	0x0C, 0xBD, 0xEF, 0x2B, 0x2A, 0x5F, 0xDA, 0xAA, 0x13, 0x63, 0x03, 0x2E, 0xAC, 0x2B, 0x42, 0xE3,
	0x00, 0x27, 0x24, 0xE0, 0x07, 0xD2, 0x24, 0xDD, 0x22, 0xB6, 0x74, 0x4A, 0x5D, 0x36, 0x98, 0xF8,
	0x77, 0xE2, 0xA4, 0xDB, 0xDA, 0x31, 0x21, 0xC4, 0x01, 0xA9, 0x87, 0xD8, 0x7E, 0x7E, 0xF6, 0x7B,
	0x51, 0x5A, 0xD4, 0x9A, 0xA3, 0x2A, 0x75, 0x20, 0xD6, 0x11, 0x8B, 0xB7, 0xA2, 0xE4, 0xF5, 0x52,
	0x6A, 0x3C, 0x5B, 0x1B, 0x85, 0xD2, 0x66, 0x3E, 0x8B, 0x1D, 0xA0, 0x88, 0x58, 0x3F, 0xEF, 0xF3,
	0xBE, 0xB0, 0xA8, 0x75, 0x14, 0xA6, 0x4A, 0xAF, 0x6A, 0x0C, 0xF0, 0x7D, 0x25, 0x27, 0x10, 0x26,
	0x2C, 0x09, 0x21, 0xD0, 0x6C, 0xE9, 0x82, 0x9C, 0x02, 0x25, 0xF6, 0xC7, 0x37, 0xB6, 0xA8, 0x5D,
	0x81, 0x53, 0x54, 0xA9, 0x0F, 0x39, 0x09, 0x13, 0x91, 0x40, 0x06, 0x2D, 0x7E, 0x6C, 0x06, 0xC4,
	0xDB, 0x22, 0x02, 0x94, 0x1B, 0x84, 0xBE, 0x8F, 0xDB, 0x90, 0x79, 0x0B, 0x33, 0x57, 0x42, 0x48,
	0xFD, 0x1D, 0x55, 0x94, 0xC6, 0x4A, 0x10, 0x91, 0xDB, 0x13, 0xD2, 0xDC, 0xD8, 0x31, 0x63, 0x8B,
	0xAF, 0xEA, 0x7C, 0xA9, 0x2C, 0x2B, 0xD8, 0xEF, 0x99, 0xBD, 0x49, 0x3A, 0xC5, 0x63, 0x87, 0x19,
	0x50, 0x4F, 0x67, 0x9B, 0x72, 0x85, 0xBB, 0x51, 0x4E, 0xAD, 0x8D, 0x29, 0xBD, 0x57, 0xE2, 0xF4,
	0x86, 0x89, 0xAA, 0x9E, 0xE5, 0x42, 0x72, 0x94, 0x82, 0xD0, 0x31, 0x49, 0xB2, 0x22, 0x2D, 0xA1,
	0xC7, 0x13, 0x65, 0x6F, 0xCF, 0xC9, 0x04, 0xAF, 0x64, 0x9B, 0x16, 0x52, 0x34, 0x59, 0x8A, 0x22,
	0xBB, 0xD5, 0x6C, 0x51, 0xCE, 0x02, 0x6F, 0x29, 0x58, 0x72, 0x70, 0xC6, 0xA6, 0x03, 0x5B, 0xA3,
	0xBA, 0xDF, 0x33, 0x4C, 0x2B, 0x37, 0xAC, 0xE3, 0x73, 0x16, 0xC6, 0x63, 0x5A, 0x76, 0x68, 0xAF,
	0x06, 0x6E, 0xEF, 0xA6, 0xE0, 0xC3, 0x11, 0x85, 0x77, 0x6A, 0xA6, 0x90, 0x2D, 0x9A, 0xD4, 0x05,
	0xA5, 0xA6, 0x65, 0xAD, 0x51, 0x9A, 0xBD, 0x70, 0xCF, 0x98, 0xF9, 0x49, 0x03, 0x34, 0x1D, 0x13,
	0x54, 0x35, 0x9D, 0x4B, 0xFE, 0x4A, 0xE2, 0xE2, 0xAD, 0x91, 0x58, 0x1B, 0x1D, 0x9C, 0xA7, 0xEC,
	0x06, 0x02, 0xEE, 0xF3, 0x01, 0x5C, 0x03, 0x9C, 0xC0, 0x3F, 0x39, 0x37, 0x76, 0x2D, 0x6C, 0x32,
	0xC9, 0x7F, 0xE8, 0xE9, 0x38, 0x78, 0xD4, 0x53, 0x35, 0x35, 0xDF, 0x74, 0xB0, 0x52, 0xAC, 0x4A,
	0x73, 0xD2, 0xC9, 0x46, 0x72, 0x40, 0xF5, 0x3F, 0x3A, 0x79, 0x4E, 0x3E, 0x3D, 0xD6, 0x68, 0xEF,
	0xA2, 0x6D, 0xE6, 0x83, 0x3E, 0x24, 0x8E, 0xAC, 0xA4, 0xD4, 0xA5, 0x33, 0xFC, 0xFE, 0x65, 0x34,
	0x6A, 0x12, 0x57, 0x4D, 0x62, 0x38, 0xFC, 0x9D, 0xD9, 0xB6, 0x58, 0xB9, 0x27, 0x78, 0x62, 0x3D,
	0xE6, 0xD7, 0xEB, 0x80, 0x65, 0x03, 0x3E, 0xF0, 0xFE, 0xF7, 0xD5, 0xF1, 0xBC, 0xF3, 0x44, 0xDA,
	0x3F, 0x04, 0xD7, 0x90, 0x97, 0x1B, 0xE8, 0x48, 0x68, 0xFE, 0x09, 0x74, 0xA4, 0xA7, 0xB3, 0xDB,
	0xD0, 0xBE, 0x9B, 0xB0, 0xFB, 0x8F, 0x20, 0xAD, 0xE3, 0xDE, 0x17, 0x0E, 0xED, 0x38, 0xA0, 0x9C,
	0x04, 0x00, 0x00,'%','E','N','D'
};

PROGMEM const char fmu2_js[] = {
	0x1F, 0x8B, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x03, 0x8D, 0x92, 0x3D, 0x6F, 0xC2, 0x30,
	0x10, 0x86, 0x77, 0x7E, 0x85, 0xE5, 0x81, 0x24, 0x0A, 0x10, 0x68, 0xBB, 0xD9, 0x89, 0x54, 0x55,
	0xFD, 0x5A, 0xDA, 0x81, 0x76, 0x42, 0x0C, 0x97, 0xE4, 0x42, 0x2C, 0x12, 0x1F, 0xB2, 0x4D, 0x33,
	0x20, 0xFE, 0x7B, 0x6D, 0x44, 0x3F, 0xC6, 0x0C, 0xB6, 0x75, 0xA7, 0x7B, 0xEE, 0x7D, 0xEF, 0xE4,
	0xE6, 0xA8, 0x2B, 0xA7, 0x48, 0xB3, 0x86, 0x4C, 0x6F, 0x1D, 0x18, 0x17, 0x43, 0x72, 0xAA, 0x87,
	0x38, 0x92, 0x21, 0xC3, 0x7A, 0x74, 0x2D, 0xD5, 0x39, 0x7F, 0x7E, 0xFC, 0xE0, 0x0C, 0x2E, 0xA5,
	0x39, 0x8F, 0x52, 0x48, 0x23, 0x5E, 0x44, 0xC9, 0xB9, 0xF9, 0xC1, 0xAD, 0xC5, 0x0E, 0x2B, 0x0F,
	0xCF, 0xCA, 0x59, 0x95, 0x9C, 0x7C, 0x64, 0x7D, 0x23, 0xB1, 0xCA, 0xF3, 0x6A, 0x3A, 0xA5, 0x83,
	0x8B, 0x39, 0x9F, 0xF1, 0xB9, 0x3F, 0x0F, 0x2D, 0x91, 0x45, 0x46, 0x1A, 0x79, 0x22, 0xBC, 0x44,
	0x0C, 0xF9, 0x52, 0x80, 0xB4, 0xA8, 0x2D, 0x19, 0xBB, 0xE8, 0x50, 0xEF, 0x5C, 0x2B, 0x20, 0x4D,
	0x93, 0x40, 0x5D, 0xD3, 0x1B, 0xD8, 0x6E, 0x96, 0x5B, 0xDF, 0xFA, 0x5F, 0xBC, 0xDA, 0x26, 0x22,
	0x88, 0xC6, 0xC9, 0x79, 0xF2, 0x6B, 0xA3, 0x47, 0x7D, 0x0C, 0x1E, 0xAE, 0x23, 0xD4, 0xEA, 0x8B,
	0x29, 0xEF, 0xBE, 0x45, 0xA8, 0xD1, 0xF0, 0x62, 0xED, 0x68, 0x8F, 0xA6, 0x24, 0xC7, 0xD6, 0xB7,
	0x6C, 0xCE, 0x9E, 0x94, 0xE9, 0x07, 0x30, 0xC8, 0x6E, 0x16, 0xAB, 0x3B, 0x59, 0x9A, 0x42, 0x02,
	0x6B, 0x0D, 0x36, 0x39, 0xCF, 0x78, 0xF1, 0x42, 0x3D, 0xCA, 0x0C, 0x8A, 0xA9, 0x2E, 0xED, 0x41,
	0xFC, 0xBF, 0xFF, 0xAA, 0x2C, 0x3A, 0xA7, 0xF4, 0xCE, 0x66, 0x3B, 0xD4, 0x68, 0xA0, 0xF3, 0xD8,
	0xFA, 0x9A, 0x92, 0x23, 0x49, 0x8D, 0xCE, 0x53, 0x6F, 0xE8, 0x06, 0x32, 0xFB, 0xD1, 0x7A, 0x03,
	0x96, 0x55, 0xA7, 0x50, 0x07, 0xF6, 0xF3, 0xD0, 0x51, 0x18, 0x6F, 0x34, 0xAC, 0xC8, 0x53, 0xAF,
	0xD9, 0xFB, 0x68, 0x00, 0x3A, 0x30, 0xBD, 0x67, 0xEE, 0xC3, 0x6B, 0x03, 0x26, 0x33, 0xBF, 0xDA,
	0xE2, 0xB2, 0xB2, 0xCA, 0xBB, 0x40, 0x13, 0x3E, 0x83, 0x98, 0x7C, 0x03, 0x72, 0x3D, 0x40, 0x73,
	0x4E, 0x02, 0x00, 0x00,'%','E','N','D'
};

PROGMEM const char loader_js[] = {
	0x1F, 0x8B, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x65, 0x8F, 0x41, 0x0E, 0x82, 0x30,
	0x14, 0x44, 0xF7, 0x9E, 0xA2, 0xE9, 0xA6, 0x10, 0x13, 0x9A, 0xE8, 0x12, 0xCB, 0x49, 0xDC, 0x34,
	0xF5, 0x13, 0x8A, 0xA5, 0x60, 0xFF, 0xAF, 0x42, 0x8C, 0x77, 0xB7, 0x84, 0x18, 0x15, 0xB6, 0x6F,
	0x26, 0x93, 0x37, 0x75, 0xF4, 0x86, 0x6C, 0xEF, 0x59, 0x80, 0x5B, 0xB4, 0x01, 0x32, 0x9D, 0x3F,
	0x2F, 0xBD, 0x89, 0x1D, 0x78, 0x2A, 0x1E, 0xC1, 0x12, 0x64, 0xE2, 0x84, 0x26, 0xD8, 0x81, 0x18,
	0x4D, 0x03, 0x28, 0x4E, 0x30, 0x92, 0x6C, 0xF5, 0x5D, 0x2F, 0x94, 0x33, 0x0C, 0x46, 0x71, 0xB1,
	0xD7, 0x7B, 0xC1, 0xAB, 0xF3, 0x78, 0x34, 0x72, 0x09, 0x2A, 0x91, 0xBF, 0x3E, 0xA3, 0x5C, 0xD6,
	0x5D, 0x2C, 0x5A, 0xE4, 0x79, 0xF9, 0x87, 0x0E, 0x6B, 0xA6, 0x9D, 0x45, 0xDA, 0x42, 0x1D, 0x3A,
	0x5C, 0x53, 0xFC, 0x56, 0x37, 0xC2, 0xCE, 0xFA, 0x6B, 0x7A, 0xE4, 0x14, 0x47, 0x9A, 0x1C, 0x60,
	0x03, 0x90, 0x44, 0x7F, 0xFC, 0x0D, 0x22, 0x67, 0x4D, 0x80, 0x5A, 0xA5, 0xA1, 0xB9, 0x52, 0xCC,
	0x44, 0x26, 0xE7, 0x72, 0xF7, 0x06, 0xF2, 0x64, 0x7B, 0x58, 0x13, 0x01, 0x00, 0x00,
	'%','E','N','D'
};

PROGMEM const char style_css[] = {
	0x1F, 0x8B, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xC5, 0x56, 0x4D, 0x8F, 0xDB, 0x36,
	0x10, 0xBD, 0x1B, 0xF0, 0x7F, 0x18, 0x78, 0x0F, 0x4E, 0xD2, 0xD8, 0x6B, 0xCB, 0x6B, 0xAF, 0x23,
	0x9F, 0x72, 0xC8, 0x16, 0x05, 0xBA, 0x45, 0xD1, 0x6D, 0xD1, 0x33, 0x25, 0x8E, 0x24, 0x26, 0x34,
	0x29, 0x88, 0xB4, 0xBD, 0x9B, 0x45, 0xFF, 0x7B, 0x87, 0xD4, 0x87, 0x65, 0x5B, 0x76, 0x37, 0x0D,
	0x92, 0x48, 0x80, 0x2D, 0x91, 0xC3, 0x99, 0x37, 0xEF, 0x71, 0x86, 0x8A, 0x34, 0x7F, 0x02, 0x78,
	0xEE, 0xF7, 0x00, 0x22, 0x16, 0x7F, 0x4A, 0x0B, 0xBD, 0x51, 0x3C, 0x84, 0xAB, 0x0F, 0xEF, 0xEE,
	0x82, 0xBB, 0xC5, 0xCA, 0x8D, 0xAF, 0x59, 0x91, 0x0A, 0x15, 0xC2, 0xC4, 0xBF, 0x59, 0x7C, 0xB4,
	0x23, 0x26, 0x45, 0x4A, 0x23, 0x31, 0x2A, 0x8B, 0xC5, 0x0A, 0xE0, 0xFA, 0x0D, 0xDC, 0x3F, 0xFC,
	0xF2, 0x01, 0xE6, 0xC0, 0x35, 0x1A, 0x35, 0xB4, 0xD5, 0x14, 0xF9, 0x34, 0xC8, 0x41, 0x2B, 0x60,
	0x1B, 0xAB, 0x41, 0x62, 0x62, 0xAF, 0x0B, 0x91, 0x66, 0xB6, 0x72, 0x6A, 0xDE, 0x3A, 0x97, 0xE7,
	0xAE, 0x68, 0x63, 0x61, 0xD8, 0x8A, 0x57, 0xFA, 0x1C, 0xFA, 0x18, 0x75, 0x00, 0xAB, 0xF3, 0x91,
	0xC4, 0x2D, 0x4A, 0xE0, 0x62, 0x6B, 0x42, 0x78, 0x73, 0xED, 0x21, 0x0B, 0x35, 0xDA, 0x09, 0x6E,
	0xB3, 0x10, 0xA6, 0x93, 0xC9, 0x24, 0x7F, 0x5C, 0x95, 0x1E, 0x09, 0xE7, 0x43, 0x8E, 0xB1, 0x48,
	0x9E, 0x80, 0xED, 0x8D, 0x20, 0xD1, 0xE4, 0x28, 0x43, 0x88, 0x1C, 0x19, 0xCC, 0x00, 0x8D, 0xA2,
	0xFB, 0x77, 0x63, 0xC3, 0x5D, 0xC1, 0xF2, 0x9C, 0xC2, 0x5E, 0x42, 0x0A, 0x28, 0x71, 0x4D, 0x80,
	0x40, 0x58, 0x83, 0x32, 0x19, 0xC3, 0x9F, 0x99, 0x30, 0x90, 0x17, 0x04, 0x4C, 0x59, 0x03, 0x0A,
	0x53, 0x66, 0xC5, 0x16, 0xE1, 0x95, 0x18, 0xE3, 0x18, 0x84, 0x62, 0x71, 0x8C, 0xC6, 0x88, 0x48,
	0xE2, 0xEB, 0x8B, 0x6E, 0x1D, 0x61, 0xA3, 0x8A, 0x2A, 0x5A, 0x06, 0x8A, 0x15, 0x85, 0xDE, 0x41,
	0x44, 0x3F, 0x86, 0x92, 0xDF, 0x09, 0xC5, 0xE9, 0x09, 0x76, 0x19, 0x2A, 0xD8, 0x18, 0xA1, 0xD2,
	0x8B, 0xDE, 0x7E, 0x63, 0x5B, 0x41, 0x40, 0x28, 0xD9, 0xC5, 0x4F, 0xD7, 0xF7, 0xFA, 0xB3, 0x90,
	0x92, 0x39, 0x6D, 0xFE, 0x16, 0x6A, 0x16, 0x94, 0xD4, 0xFD, 0xD3, 0xEF, 0xF5, 0x7B, 0x57, 0xB1,
	0x56, 0x96, 0x09, 0x45, 0x11, 0x9E, 0x8F, 0x25, 0x77, 0x88, 0x56, 0x15, 0x95, 0x7F, 0xA0, 0x41,
	0x0B, 0x7E, 0xC2, 0x27, 0x4F, 0x0A, 0xC7, 0x7A, 0x9D, 0xA3, 0x32, 0xCC, 0xA2, 0x27, 0xB5, 0x43,
	0xBD, 0x5A, 0xA2, 0x2E, 0x79, 0x0E, 0x04, 0x72, 0xE4, 0x97, 0xF2, 0xE8, 0xC4, 0xBF, 0x54, 0x1C,
	0x57, 0xE4, 0x9A, 0x4C, 0x6F, 0x24, 0x87, 0x08, 0xFD, 0x9C, 0x61, 0x6B, 0xBC, 0x94, 0x3B, 0x89,
	0x39, 0xF4, 0xEA, 0x36, 0xA2, 0x37, 0x40, 0x4A, 0x7A, 0x47, 0x2E, 0xB1, 0xD0, 0x6F, 0xD3, 0x55,
	0x85, 0x83, 0x72, 0x73, 0x83, 0xC0, 0x14, 0x87, 0x83, 0x4D, 0xEB, 0x12, 0x75, 0x86, 0x6F, 0x29,
	0xF4, 0xA6, 0xDE, 0x89, 0x44, 0xBE, 0x43, 0x72, 0x09, 0x44, 0xB3, 0x49, 0x94, 0xC7, 0x5C, 0xB1,
	0xEC, 0x16, 0xBE, 0x72, 0xD8, 0x5E, 0x83, 0x65, 0xE9, 0x11, 0x2A, 0x1F, 0xB7, 0x82, 0x55, 0xAB,
	0x93, 0x21, 0xE3, 0x4E, 0x1A, 0x28, 0x63, 0xE5, 0x8C, 0x73, 0xF2, 0x11, 0xC2, 0x6C, 0x9E, 0x3F,
	0xC2, 0x8C, 0xD8, 0x84, 0xFA, 0x61, 0x55, 0x5A, 0x1C, 0x14, 0xF6, 0x2C, 0xBA, 0x5D, 0x2C, 0x6F,
	0xAB, 0x99, 0x0C, 0x4B, 0xFF, 0xD3, 0xC9, 0xDE, 0x3A, 0xD6, 0x52, 0x17, 0x64, 0x78, 0xE7, 0xAF,
	0x6A, 0xD0, 0xEB, 0xC8, 0x31, 0xD6, 0x05, 0x6D, 0x64, 0x4D, 0xFB, 0x40, 0x69, 0x85, 0xD5, 0x5C,
	0x42, 0x79, 0x8C, 0x8C, 0xF8, 0x8C, 0x61, 0x3B, 0xA8, 0x1F, 0x4D, 0xD8, 0x5A, 0xC8, 0xA7, 0x10,
	0x06, 0xF7, 0x4F, 0x85, 0x60, 0x1C, 0x7E, 0x2F, 0xF4, 0xC0, 0xE5, 0x01, 0xED, 0x44, 0x58, 0xB9,
	0xCB, 0xBE, 0x2E, 0xF2, 0x74, 0xF9, 0xB2, 0xC8, 0x3E, 0x30, 0xA9, 0xB0, 0x99, 0xD6, 0x51, 0xF7,
	0xEC, 0x8C, 0x6A, 0x00, 0x07, 0x1C, 0x35, 0xFC, 0x2E, 0x6A, 0x7A, 0xDD, 0xC3, 0xA4, 0x0E, 0x26,
	0x35, 0xB3, 0x55, 0x59, 0x1C, 0xBA, 0x3F, 0x49, 0x2B, 0x9E, 0xF3, 0x05, 0x8F, 0xBE, 0x30, 0xAD,
	0x9B, 0x2F, 0x4E, 0x8B, 0x85, 0x99, 0xDE, 0xD6, 0xA5, 0xBB, 0x8F, 0x8E, 0x71, 0x12, 0x24, 0xB3,
	0x03, 0xDB, 0xE0, 0xDB, 0x52, 0x10, 0xFC, 0x20, 0x0A, 0x82, 0x17, 0x52, 0x20, 0xD6, 0x2C, 0xC5,
	0x48, 0x3F, 0x7E, 0x33, 0x16, 0xFA, 0xBD, 0x71, 0x5E, 0xE8, 0x8F, 0x18, 0xDB, 0x3A, 0x44, 0x75,
	0x94, 0x4E, 0x5D, 0x81, 0x4E, 0x20, 0x98, 0x57, 0xEB, 0xBD, 0x75, 0x36, 0x3D, 0xB2, 0x82, 0xD3,
	0x9A, 0x5C, 0x2E, 0xDE, 0x2D, 0x6F, 0x66, 0x27, 0x1C, 0x05, 0xE7, 0x28, 0x7A, 0x4F, 0x0C, 0x49,
	0xEA, 0xFB, 0xEE, 0xD4, 0x18, 0xB4, 0x2D, 0x76, 0x55, 0xE1, 0x2B, 0x5D, 0xAC, 0x99, 0x6C, 0x20,
	0x04, 0xC7, 0x94, 0x1D, 0x10, 0xD0, 0x16, 0x65, 0xDE, 0x44, 0xAC, 0xD1, 0x06, 0x13, 0x9F, 0xD4,
	0x61, 0x4E, 0xB3, 0x17, 0x3B, 0x0C, 0x4E, 0x1C, 0x96, 0xFE, 0x26, 0x6D, 0x7F, 0x57, 0x6B, 0x6A,
	0x98, 0x17, 0xF4, 0x6A, 0x3A, 0x47, 0xD5, 0x61, 0xDC, 0x16, 0x6B, 0x1A, 0x65, 0xE3, 0xB7, 0xBC,
	0x9B, 0x78, 0x8D, 0xAE, 0x5E, 0x0F, 0x9F, 0x46, 0xF3, 0x74, 0xC4, 0xFF, 0x8D, 0xBF, 0x3A, 0xA9,
	0xFE, 0x19, 0x35, 0xB9, 0x67, 0x83, 0x8E, 0xD4, 0x66, 0x8D, 0x1F, 0x49, 0x87, 0xEA, 0xA8, 0x69,
	0xBA, 0xFB, 0x96, 0xD5, 0x3E, 0x61, 0x3F, 0x6E, 0x8C, 0xA5, 0xF3, 0xEF, 0x28, 0x09, 0x76, 0x91,
	0xC8, 0x73, 0xA5, 0xE4, 0x49, 0x3B, 0x59, 0x7A, 0x90, 0xC5, 0xC5, 0xA5, 0xE3, 0x48, 0xA4, 0x84,
	0xF9, 0xD3, 0xFF, 0x0A, 0x7E, 0x5A, 0xC7, 0xFB, 0xFE, 0x50, 0xE6, 0xD4, 0x5D, 0xA6, 0x0D, 0xBC,
	0xD2, 0x34, 0xD1, 0xDA, 0xEE, 0x8D, 0xBA, 0x8B, 0xF0, 0xDC, 0x61, 0x47, 0xDD, 0x86, 0xEE, 0x4E,
	0xBD, 0x7E, 0xDD, 0xC4, 0x82, 0x33, 0x78, 0x60, 0x74, 0x9E, 0xFF, 0xA5, 0x44, 0xAC, 0x39, 0x0E,
	0xFE, 0x53, 0xED, 0x2A, 0x93, 0x69, 0xA7, 0x70, 0xFE, 0xAC, 0x3E, 0x86, 0xDD, 0x90, 0x7F, 0x89,
	0xA5, 0x3A, 0x60, 0xB0, 0x70, 0xF7, 0x89, 0x8B, 0x6E, 0x9A, 0x16, 0xFE, 0x6A, 0x94, 0x32, 0x98,
	0xB3, 0xC2, 0x7F, 0xDC, 0x3D, 0x1F, 0x03, 0x6E, 0xE1, 0x2D, 0x17, 0xB7, 0xEA, 0xC4, 0xAF, 0x8D,
	0x25, 0xB2, 0xBD, 0x7F, 0xF7, 0x12, 0x46, 0xDA, 0x66, 0xF5, 0x7C, 0x22, 0x50, 0x72, 0xFA, 0xD4,
	0xEB, 0xF7, 0xEA, 0xCA, 0xD3, 0x05, 0x1D, 0xDC, 0x44, 0x04, 0x51, 0x6F, 0xB4, 0x14, 0xBC, 0xB5,
	0x23, 0xFC, 0x0A, 0x89, 0x29, 0x2A, 0xDE, 0xD8, 0x77, 0xB6, 0xFF, 0xF3, 0x5F, 0x25, 0x1D, 0xEE,
	0x6F, 0x97, 0xD3, 0xD9, 0x7C, 0x7A, 0x52, 0xB0, 0xA5, 0xFC, 0x75, 0x1A, 0x42, 0x25, 0x9A, 0xFA,
	0xF9, 0x77, 0x0E, 0x6B, 0xDD, 0x67, 0xCC, 0x51, 0xCC, 0x73, 0x6D, 0xAE, 0x6A, 0x9B, 0xE5, 0x3A,
	0x27, 0xEF, 0xD9, 0x75, 0xDE, 0xE4, 0x5F, 0x44, 0x45, 0x07, 0x30, 0x9D, 0x0D, 0x00, 0x00,
	'%','E','N','D'
};
#endif

//called once per second
void initTimedEvents()
{
	printf("Init timed_events \r\n");
	for (uint16_t i=0; i<(12*4); i++)
	{
		timed_events[i] = 0;
	}
}

void checkTimedEvents()
{
	uptime++;

	for (uint8_t i=0; i<12; i++)
	{
		if (timed_events[i*4] != 0)
		{
			printf("Found timed event %u %u %u %u %u... \r\n", i, timed_events[(i*4)+0], timed_events[(i*4)+1], timed_events[(i*4)+2], timed_events[(i*4)+3]);

			#if SBNG_TARGET == 50
			if (timed_events[(i*4)+1] >= 4 && (timed_events[(i*4)+1] < 20 || timed_events[(i*4)+1] > 29))
			{
				printf("Pin not in acceptable range (%u)\r\n",timed_events[(i*4)+1]);
				break;
			}
			#else
			if (timed_events[(i*4)+1] >= 4)
			{
				printf("Pin not in acceptable range (%u)\r\n",timed_events[(i*4)+1]);
				break;
			}
			#endif

			timed_events[(i*4)+3] = timed_events[(i*4)+3]-1;

			if (timed_events[(i*4)+3] == 0)
			{
				printf("TIMEOUT\r\n");
				//reverse the pin
				#if SBNG_TARGET == 50
					if (timed_events[(i*4)+1] > 20)
					{
						if (timed_events[(i*4)+2] == 1)
							simpleSensorValues[timed_events[(i*4)+1]] = 0;
						else
							simpleSensorValues[timed_events[(i*4)+1]] = 1;
					} else {
				#endif
				if (timed_events[(i*4)+2] == 1)
					CLEARBIT(PORTC, (2+timed_events[(i*4)+1]));
				else
					SETBIT(PORTC, (2+timed_events[(i*4)+1]));
				#if SBNG_TARGET == 50
				}
				#endif
				//reset the array
				timed_events[(i*4)+0] = 0;
				timed_events[(i*4)+1] = 0;
				timed_events[(i*4)+2] = 0;
				timed_events[(i*4)+3] = 0;
			}
		}
	}
}

void addTimedEvent(uint8_t id, uint8_t pin, uint8_t state, uint8_t delay)
{
	printf("addTimedEvent(%d, %d, %d, %d)\r\n",id,pin,state,delay);

	for (uint8_t i=0; i<12; i++)
	{
		if (timed_events[i*4] == 0)
		{
			timed_events[(i*4)+0] = id;
			timed_events[(i*4)+1] = pin;
			timed_events[(i*4)+2] = state;
			timed_events[(i*4)+3] = delay;
			break;
		}
	}
}


uint16_t http200ok(void)
{
        return(fill_tcp_data_p(buf,0,PSTR("HTTP/1.0 200 OK\r\nContent-Type: text/html\r\nPragma: no-cache\r\n\r\n")));
}

uint16_t http200gzok(void)
{
        return(fill_tcp_data_p(buf,0,PSTR("HTTP/1.0 200 OK\r\nContent-Encoding: gzip\r\nContent-Type: text/html\r\nPragma: no-cache\r\n\r\n")));
}

uint16_t https401(void)
{
        return(fill_tcp_data_p(buf,0,PSTR("HTTP/1.0 401 Authorization Required\r\nWWW-Authenticate: Basic realm=\"Stokerbot admin\"\r\nContent-Type: text/html\r\nPragma: no-cache\r\n\r\n")));
}


uint16_t print_export_htm(uint8_t *buf)
{
        uint16_t plen;

		plen=http200ok();
		
		sprintf(tempbuf, "Uptime %lu \r\n", uptime);
		plen = fill_tcp_data(buf,plen,tempbuf);

	    for (uint8_t i=0; i<MAXSENSORS; i++)
	    {  
	      if (sensorValues[(i*SENSORSIZE)+FAMILY] != 0)
	      {
	        int frac = sensorValues[(i*SENSORSIZE)+VALUE2]*DS18X20_FRACCONV;  //Ganger de sidste par bits, med det step DS18B20 bruger
    
	        sprintf_P(tempbuf, PSTR("%02X%02X%02X%02X%02X%02X%02X%02X %c%d.%04d\r\n"),
	              sensorValues[(i*SENSORSIZE)+FAMILY],
	              sensorValues[(i*SENSORSIZE)+ID1],
	              sensorValues[(i*SENSORSIZE)+ID2],
	              sensorValues[(i*SENSORSIZE)+ID3],
	              sensorValues[(i*SENSORSIZE)+ID4],
	              sensorValues[(i*SENSORSIZE)+ID5],
	              sensorValues[(i*SENSORSIZE)+ID6],
	              sensorValues[(i*SENSORSIZE)+CRC],
	              sensorValues[(i*SENSORSIZE)+SIGN],
	              sensorValues[(i*SENSORSIZE)+VALUE1],
	              frac
	            );      

	            plen = fill_tcp_data(buf,plen,tempbuf);
	      }
		}
	
		//Analog pins
		for (uint8_t i=0; i<=7; i++)
		{
			sprintf_P(tempbuf, PSTR("A%u %u\r\n"),i,simpleSensorValues[i]);
			plen = fill_tcp_data(buf,plen,tempbuf);
		}

		//Digital pins
		for (uint8_t i=0; i<=3; i++)
		{
			sprintf_P(tempbuf, PSTR("D%u %u\r\n"),i,simpleSensorValues[i+8]);
			plen = fill_tcp_data(buf,plen,tempbuf);
		}
#if SBNG_TARGET == 50
		//Relay states
		for (uint8_t i=24; i<=27; i++)
		{
			sprintf_P(tempbuf, PSTR("RL%u %u\r\n"),i,simpleSensorValues[i]);
			plen = fill_tcp_data(buf,plen,tempbuf);
		}

		//Opto states
		for (uint8_t i=20; i<=23; i++)
		{
			sprintf_P(tempbuf, PSTR("OP%u %u\r\n"),i,simpleSensorValues[i]);
			plen = fill_tcp_data(buf,plen,tempbuf);
		}
#endif
		for (uint8_t i=0; i<4; i++)
		{
			if (simpleSensorTypes[i+8] == TYPE_DHT22)
			{
				float temperature=0;
				float humidity=0;
				if(simpleSensorValues[50] & 0x8000) {
					temperature = (float)((simpleSensorValues[50+(i*2)] & 0x7FFF) / 10.0) * -1.0;
					} else {
					temperature = (float)(simpleSensorValues[50+(i*2)])/10.0;
				}
				humidity = (float)(simpleSensorValues[50+(i*2)+1])/10.0;
				sprintf_P(tempbuf, PSTR("D%dT %g\r\nD%dH %g\r\n"),i,temperature,i,humidity);
				plen = fill_tcp_data(buf,plen,tempbuf);
			}
			if (simpleSensorTypes[i+8] == TYPE_DHT11)
			{
				float temperature=simpleSensorValues[50+(i*2)];
				float humidity=simpleSensorValues[50+(i*2)+1];
				sprintf_P(tempbuf, PSTR("D%dT %g\r\nD%dH %g\r\n"),i,temperature,i,humidity);
				plen = fill_tcp_data(buf,plen,tempbuf);
			}
		}

        return plen;
}



// prepare the webpage by writing the data to the tcp send buffer
uint16_t print_webpage(uint8_t *buf)
{
        uint16_t plen;

		plen=http200ok();

		sprintf_P(tempbuf, PSTR("<SCRIPT SRC='/loader.js?%u'></SCRIPT>"),tickS);
		plen=fill_tcp_data(buf,plen,tempbuf);

		sprintf_P(tempbuf, PSTR("<SCRIPT>menu(2,1);</SCRIPT><PRE>"));
		plen=fill_tcp_data(buf,plen,tempbuf);

		sprintf_P(tempbuf, PSTR("\nSystemID: %02X%02X%02X%02X%02X%02X%02X%02X\n"),systemID[0],systemID[1],systemID[2],systemID[3],systemID[4],systemID[5],systemID[6],systemID[7]);
		plen=fill_tcp_data(buf,plen,tempbuf);

        if (client_waiting_gw()){
                plen=fill_tcp_data_p(buf,plen,PSTR("\nwaiting for GW IP to answer arp.\n"));
                return(plen);
        }
        if (dns_state==1){
                plen=fill_tcp_data_p(buf,plen,PSTR("\nwaiting for DNS answer.\n"));
                return(plen);
        }


		uint8_t days = 0;
		uint8_t hours = 0;
		uint8_t minutes = 0;
		uint8_t seconds = 0;
		uint32_t up = uptime;
		while (up >= 86400)
		{
			days++;
			up -= 86400;
		}
		while (up >= 3600)
		{
			hours++;
			up -= 3600;
		}
		while (up >= 60)
		{
			minutes++;
			up -= 60;
		}
		seconds = up;

		sprintf_P(tempbuf, PSTR("\nUptime: %udays %uhours %uminutes %useconds\n"),days, hours, minutes, seconds);
		plen=fill_tcp_data(buf,plen,tempbuf);

        plen=fill_tcp_data_p(buf,plen,PSTR("\nNumber of data uploads : "));
        // convert number to string:
        itoa(web_client_attempts,tempbuf,10);
        plen=fill_tcp_data(buf,plen,tempbuf);

        plen=fill_tcp_data_p(buf,plen,PSTR("\nNumber successful data uploads : "));
        // convert number to string:
        itoa(web_client_sendok,tempbuf,10);
        plen=fill_tcp_data(buf,plen,tempbuf);

		plen=fill_tcp_data_p(buf,plen,PSTR("</pre><script>for (i=0; i < sensors.length; i++) { dw(sensors[i][1]+' = '+sensors[i][2]+'<br>'); }</script>"));
		
		//Debug for at se hvor tæt vi er på grænsen (buffer size - lidt)
		printf_P(PSTR("Plen is %d \r\n"), plen);
        
		return(plen);
}


// prepare the webpage by writing the data to the tcp send buffer

uint16_t print_sensorlist(uint8_t *buf)
{
        uint16_t plen;
		bool first = true;

		plen=http200ok();
    
		sprintf_P(tempbuf, PSTR("var sensors=["));
		plen = fill_tcp_data(buf,plen,tempbuf);

	    for (uint8_t i=0; i<MAXSENSORS; i++)
	    {  
	      if (sensorValues[(i*SENSORSIZE)+FAMILY] != 0)
	      {
		  	if (!first)
				plen = fill_tcp_data(buf,plen,",");
			else
				first=false;

	        int frac = sensorValues[(i*SENSORSIZE)+VALUE2]*DS18X20_FRACCONV;  //Ganger de sidste par bits, med det step DS18B20 bruger
    
	        sprintf_P(tempbuf, PSTR("[%u, '%02X%02X%02X%02X%02X%02X%02X%02X', '%c%d.%04d']"),i,
	              sensorValues[(i*SENSORSIZE)+FAMILY],
	              sensorValues[(i*SENSORSIZE)+ID1],
	              sensorValues[(i*SENSORSIZE)+ID2],
	              sensorValues[(i*SENSORSIZE)+ID3],
	              sensorValues[(i*SENSORSIZE)+ID4],
	              sensorValues[(i*SENSORSIZE)+ID5],
	              sensorValues[(i*SENSORSIZE)+ID6],
	              sensorValues[(i*SENSORSIZE)+CRC],
	              sensorValues[(i*SENSORSIZE)+SIGN],
	              sensorValues[(i*SENSORSIZE)+VALUE1],
	              frac
	            );      

	            plen = fill_tcp_data(buf,plen,tempbuf);
	      }
		}
	
		plen=fill_tcp_data_p(buf,plen,PSTR("];"));

        return plen;
}

uint16_t print_alarmlist(uint8_t *buf)
{
/*

400 Alarm 1 enabled?
401 Alarm 1 address 1
402 Alarm 1 address 2
403 Alarm 1 address 3
404 Alarm 1 address 4
405 Alarm 1 address 5
406 Alarm 1 address 6
407 Alarm 1 address 7
408 Alarm 1 address 8
409 Alarm 1 type
410 Alarm 1 value
411 Alarm 1 target (0-3)
412 Alarm 1 state (during alarm) (0/1)
413 Alarm 1 reverse?

1 400
2 415
3 430
4 445

*/
        uint16_t plen;

		plen=http200ok();

		plen=fill_tcp_data_p(buf,plen,PSTR("var alarms = new Array();"));

		for (uint8_t alarm=1; alarm<=NUMALARMS; alarm++)
		{
			uint16_t pos = 400 + ((alarm-1)*15); //400 415 430 445
			uint16_t sensorid  = 255;
			if (eepromReadByte(pos+1) != 0 && eepromReadByte(pos+1) != 0xFF)
			{
					sensorid = findSensor(
					eepromReadByte(pos+1), eepromReadByte(pos+2), eepromReadByte(pos+3), eepromReadByte(pos+4),
					eepromReadByte(pos+5), eepromReadByte(pos+6), eepromReadByte(pos+7), eepromReadByte(pos+8)
				);
			}

			sprintf_P(tempbuf, PSTR("alarms[%u] = [%u, '%u','%i','%u','%u','%u','%u'];"), alarm, sensorid,
			eepromReadByte(pos+9), eepromReadByteSigned(pos+10),eepromReadByte(pos+11),eepromReadByte(pos+12),
			eepromReadByte(pos+13),eepromReadByte(pos+0));
			
			plen=fill_tcp_data(buf,plen,tempbuf);
		}
    	
        return plen;
}

uint16_t print_webclient_webpage(uint8_t *buf)
{
	uint16_t plen;
	plen=http200ok();

	uint8_t interval = eepromReadByte(1200);

	char orgurl[100];
	eepromReadStr(1101,orgurl,99);
	eepromReadStr(1000,host,99);
	sprintf_P(tempbuf, PSTR("<SCRIPT> var interval = %u; var host = '%s'; var url='%s'; </SCRIPT>"), interval, host, orgurl);
	plen=fill_tcp_data(buf,plen,tempbuf);

	plen=print_flash_webpage_only(webclient_htm, buf, plen);

	//Debug for at se hvor tæt vi er på grænsen (buffer size - lidt)
	printf_P(PSTR("Plen is %d \r\n"), plen);

	return(plen);
}

uint16_t print_settings_general_webpage(uint8_t *buf)
{
        uint16_t plen;

		plen=http200ok();
        plen=fill_tcp_data_p(buf,plen,PSTR("<SCRIPT SRC='/loader.js'></SCRIPT><script>menu(2,1);formstart('/settings/general');"));

		char realpassword[11];
		eepromReadStr(200, realpassword, 10);      
		sprintf_P(tempbuf, PSTR("dw('Password : ');tf('PASS', '%s', 10);dw('<br>');"), realpassword);
		plen=fill_tcp_data(buf,plen,tempbuf);

		uint8_t hasLcd = eepromReadByte(50);
		sprintf_P(tempbuf, PSTR("dw('LCD : ');cb('LCD', '%u', 1);dw('<br>');"), hasLcd);
		plen=fill_tcp_data(buf,plen,tempbuf);

		sprintf_P(tempbuf, PSTR("formend();</script><br>"));
		plen=fill_tcp_data(buf,plen,tempbuf);

		//Debug for at se hvor tæt vi er på grænsen (buffer size - lidt)
		printf_P(PSTR("Plen is %d \r\n"), plen);

        return(plen);
}

uint16_t print_settings_webpage(uint8_t *buf)
{
        uint16_t plen;

		plen=http200ok();
        plen=fill_tcp_data_p(buf,plen,PSTR("<SCRIPT SRC='/loader.js'></SCRIPT><script>menu(2,1);formstart('/settings/net');"));
      
		sprintf_P(tempbuf, PSTR("dw('IP : ');tf('IP0', %d, 2);tf('IP1', %d, 2);tf('IP2', %d, 2);tf('IP3', %d, 2);dw('<br>');"), myip[0], myip[1], myip[2], myip[3]);
		plen=fill_tcp_data(buf,plen,tempbuf);

		sprintf_P(tempbuf, PSTR("dw('GW : ');tf('GW0', %d, 2);tf('GW1', %d, 2);tf('GW2', %d, 2);tf('GW3', %d, 2);dw('<br>');"), gwip[0], gwip[1], gwip[2], gwip[3]);
		plen=fill_tcp_data(buf,plen,tempbuf);

		sprintf_P(tempbuf, PSTR("dw('DNS: ');tf('DNS0', %d, 2);tf('DNS1', %d, 2);tf('DNS2', %d, 2);tf('DNS3', %d, 2);dw('<br>');"), dnsip[0], dnsip[1], dnsip[2], dnsip[3]);
		plen=fill_tcp_data(buf,plen,tempbuf);

		sprintf_P(tempbuf, PSTR("dw('MASK: ');tf('MASK0', %d, 2);tf('MASK1', %d, 2);tf('MASK2', %d, 2);tf('MASK3', %d, 2);formend();</script><br>"), netmask[0], netmask[1], netmask[2], netmask[3]);
		plen=fill_tcp_data(buf,plen,tempbuf);

		//Debug for at se hvor tæt vi er på grænsen (buffer size - lidt)
		printf_P(PSTR("Plen is %d \r\n"), plen);

        return(plen);
}

uint16_t print_settings_io_webpage(uint8_t *buf)
{
        uint16_t plen;

		plen=http200ok();
        plen=fill_tcp_data_p(buf,plen,PSTR("<SCRIPT SRC='/loader.js'></SCRIPT><script>menu(2,1);formstart('/settings/io');tfh('io','1',0);dw('<table border=0>');"));
    
	  	for (uint8_t i=0; i<8; i++)
		{
			sprintf_P(tempbuf, PSTR("adcset(%d, 'ADC%d', %d);"),i,i,simpleSensorTypes[i]);
			plen=fill_tcp_data(buf,plen,tempbuf);
		}

	  	for (uint8_t i=0; i<4; i++)
		{
			sprintf_P(tempbuf, PSTR("dport(%d, 'D%d', %d);"),i,i,simpleSensorTypes[i+8]);
			plen=fill_tcp_data(buf,plen,tempbuf);
		}

		plen=fill_tcp_data_p(buf,plen,PSTR("dw('</table>');formend();</script>"));

		//Debug for at se hvor tæt vi er på grænsen (buffer size - lidt)
		printf_P(PSTR("Plen is %d \r\n"), plen);

        return(plen);
}


uint16_t print_flash_webpage(bool gzip, const char * pos, uint8_t *buf)
{
        uint16_t plen;

		if (gzip) 
			plen=http200gzok();
		else
			plen=http200ok();

		return print_flash_webpage_only(pos, buf, plen);
}

uint16_t print_flash_webpage_only(const char * pos, uint8_t* buf, uint16_t plen)
{
	uint8_t c;
	
		while (true)
		{
			if (
			(c = pgm_read_byte(pos)) == '%' &&
			pgm_read_byte(pos+1) == 'E' &&
			pgm_read_byte(pos+2) == 'N' &&
			pgm_read_byte(pos+3) == 'D'
			)
			{
				break;
			} else {
				plen = fill_tcp_data_len(buf, plen, &c, 1);
				pos++;
			}
		}

		return(plen);	
}

bool user_is_auth(char* buffer)
{
printf_P(PSTR("buf = %s \r\n"), buffer);
	char* pos = strstr_P(buffer, PSTR("Authorization"));
	pos+= 21; //Authorization: Basic
	if (pos != NULL)
	{
		char* ptr2 = (char*)pos;
		while (*ptr2 != '\r' && *ptr2 != '\n') ptr2++;
		*ptr2 = '\0';
	
		memset(tempbuf, '\0', 25);
		base64dec(tempbuf, pos, 1);

		char* password = strstr(tempbuf, ":");

		if (password != NULL)
		{
			password++;

			char realpassword[11];
			eepromReadStr(200, realpassword, 10);

			if (strcmp(password, realpassword)==0)
			{
				return true;
			}
		}

		return false;
	}
	return false;
}

//Bliver kaldt når vi er forbundet til serveren og skal sende GET url...
uint16_t fill_custom_client_data(uint8_t *bufptr,uint16_t len)
{

	if (start_web_client == 10)
		return len;

#if SBNG_TARGET == 50
		sprintf_P(tempbuf, PSTR("&ALARM=%u"), alarmTimeout);
		len = fill_tcp_data(bufptr,len,tempbuf);
#endif

	for (uint8_t i=0; i<8; i++)
	{
		sprintf_P(tempbuf, PSTR("&ADC%u=%u"), i, simpleSensorValues[i]);
		len = fill_tcp_data(bufptr,len,tempbuf);
	}

	for (uint8_t i=0; i<4; i++)
	{
		sprintf_P(tempbuf, PSTR("&D%u=%u"), i, simpleSensorValues[i+8]);
		len = fill_tcp_data(bufptr,len,tempbuf);
	}

#if SBNG_TARGET == 50
	for (uint8_t i=20; i<24; i++)
	{
		sprintf_P(tempbuf, PSTR("&O%u=%u"), i, simpleSensorValues[i]);
		len = fill_tcp_data(bufptr,len,tempbuf);
	}

	for (uint8_t i=24; i<28; i++)
	{
		sprintf_P(tempbuf, PSTR("&R%u=%u"), i, simpleSensorValues[i]);
		len = fill_tcp_data(bufptr,len,tempbuf);
	}
#endif

    for (uint8_t i=0; i<MAXSENSORS; i++)
    {  
      if (sensorValues[(i*SENSORSIZE)+FAMILY] != 0)
      {
        int frac = sensorValues[(i*SENSORSIZE)+VALUE2]*DS18X20_FRACCONV;  //Ganger de sidste par bits, med det step DS18B20 bruger
    
        sprintf_P(tempbuf, PSTR("&%02X%02X%02X%02X%02X%02X%02X%02X=%c%d.%04d"),
              sensorValues[(i*SENSORSIZE)+FAMILY],
              sensorValues[(i*SENSORSIZE)+ID1],
              sensorValues[(i*SENSORSIZE)+ID2],
              sensorValues[(i*SENSORSIZE)+ID3],
              sensorValues[(i*SENSORSIZE)+ID4],
              sensorValues[(i*SENSORSIZE)+ID5],
              sensorValues[(i*SENSORSIZE)+ID6],
              sensorValues[(i*SENSORSIZE)+CRC],
              sensorValues[(i*SENSORSIZE)+SIGN],
              sensorValues[(i*SENSORSIZE)+VALUE1],
              frac
            );      

            len = fill_tcp_data(bufptr,len,tempbuf);
      }
	}


	for (uint8_t i=0; i<4; i++)
	{
		if (simpleSensorTypes[i+8] == TYPE_DHT22)
		{
			float temperature=0;
			float humidity=0;
			if(simpleSensorValues[50] & 0x8000) {
				temperature = (float)((simpleSensorValues[50+(i*2)] & 0x7FFF) / 10.0) * -1.0;
				} else {
				temperature = (float)(simpleSensorValues[50+(i*2)])/10.0;
			}
			humidity = (float)(simpleSensorValues[50+(i*2)+1])/10.0;
			sprintf_P(tempbuf, PSTR("&D%dT=%g&D%dH=%g"),i,temperature,i,humidity);
			len = fill_tcp_data(bufptr,len,tempbuf);
		}
		if (simpleSensorTypes[i+8] == TYPE_DHT11)
		{
			float temperature=simpleSensorValues[50+(i*2)];
			float humidity=simpleSensorValues[50+(i*2)+1];
			sprintf_P(tempbuf, PSTR("&D%dT=%g&D%dH=%g"),i,temperature,i,humidity);
			len = fill_tcp_data(bufptr,len,tempbuf);
		}		
	}
		

	return len;
}

void handle_net(void)
{
	uint16_t dat_p,plen;

    // handle ping and wait for a tcp packet
    plen=enc28j60PacketReceive(BUFFER_SIZE, buf);
    dat_p=packetloop_icmp_tcp(buf,plen);

    if(plen==0){
            //Hvis der ikke er nogle indgående pakker, køres en tur i web client state machine, hvor dns lookup mv. håndteres
            if (client_waiting_gw() ){
                return;
            }

            if (dns_state==0){
					if (web_client_monitor >= 60)
					{
						printf("Reset due to missing webclient");
						while(true);
					}

					web_client_monitor++;
					eepromReadStr(1000, host, 99);
					eepromReadStr(1100, url, 99);					
					printf_P(PSTR("Request DNS lookup for %s\r\n"),host);
                    dnsTimer=tickS;
                    dns_state=1;
                    dnslkup_request(buf,host);
                    return;
            }

            if (dns_state==1 && dnslkup_haveanswer()){
					printf_P(PSTR("Got dns reply : %d.%d.%d.%d \r\n"),dnslkup_getip()[0],dnslkup_getip()[1],dnslkup_getip()[2],dnslkup_getip()[3]);
                    dns_state=2;
			        client_set_wwwip(dnslkup_getip());
            }

            if (dns_state!=2){
                    // retry every minute if dns-lookup failed:
                    if (tickDiffS(dnsTimer) > 20){
						printf_P(PSTR("Retry dns lookup ... \r\n"));
                            dns_state=0;
                    }
                    // don't try to use web client before
                    // we have a result of dns-lookup
                    return;
            }

            //----------
            if (start_web_client==1){
				printf_P(PSTR("Starting webclient request \r\n"));
					eepromReadStr(1000, host, 99);
					eepromReadStr(1100, url, 99);				
					
                    dnsTimer=tickS;
                    start_web_client=2;
                    web_client_attempts++;
					web_client_monitor++;
					if (web_client_monitor >= 5)
					{
						printf("Reset due to missing webclient");
						while(true);
					}
	
		//Add the static ID to the url, rest of data is added in callback				
		sprintf_P(tempbuf, PSTR("&id=%02X%02X%02X%02X%02X%02X%02X%02X"), systemID[0], systemID[1], systemID[2], systemID[3], systemID[4], systemID[5], systemID[6], systemID[7]);
		strcat(url, tempbuf);
		client_browse_url(url,NULL,host,&browserresult_callback);	
	} else if (start_web_client == 10)
	{
		dnsTimer=tickS;
        start_web_client=2;

		printf_P(PSTR("Starting lcd request \r\n"));
		char *ptr = (char*)tempbuf;
		sprintf_P(ptr, PSTR("?id=%02X%02X%02X%02X%02X%02X%02X%02X"), systemID[0], systemID[1], systemID[2], systemID[3], systemID[4], systemID[5], systemID[6], systemID[7]);
		ptr += strlen(ptr);
		client_browse_url("/getLCD.php",tempbuf,host,&lcd_callback);	
	}

    	// reset after a delay to prevent permanent bouncing
        if (tickDiffS(dnsTimer)>10 && start_web_client==2){
        	start_web_client=0;
        }
        return;
    }
    if(dat_p==0){ // plen!=0
            // check for incomming messages not processed
            // as part of packetloop_icmp_tcp, e.g udp messages
            udp_client_check_for_dns_answer(buf,plen);
            return;
    }
            
    if (strncmp("GET ",(char *)&(buf[dat_p]),4)!=0){
            dat_p=fill_tcp_data_p(buf,dat_p,PSTR("<h1>200 OK</h1>"));
            goto SENDTCP;
    }

    if (strncmp("/ ",(char *)&(buf[dat_p+4]),2)==0){	
            dat_p=print_webpage(buf);		

            goto SENDTCP;
    } else if (strncmp_P((char *)&(buf[dat_p+4]),PSTR("/settings/general"),17)==0){	
			if (!user_is_auth((char *)&(buf[dat_p+4])))
			{
				dat_p=https401();
          		goto SENDTCP;
			}

			char cgival[11];
			uint8_t length = 0;
			length = find_key_val((char *)&(buf[dat_p+4]),cgival, 10,"PASS");
			//Changed from a loop here i beta2, revert if it fails -JKN
			if (length > 0 && length <= 10)
			{
				eepromSaveStr(200, cgival, length);
				save_checkbox_cgivalue((char*)&(buf[dat_p+4]), "LCD", 50);
			}

            dat_p=print_settings_general_webpage(buf);

          	goto SENDTCP;
    } else if (strncmp_P((char *)&(buf[dat_p+4]),PSTR("/settings/io"),12)==0){
			if (!user_is_auth((char *)&(buf[dat_p+4])))
			{
				dat_p=https401();
          		goto SENDTCP;
			}
			char cgival[3];
			if (find_key_val((char *)&(buf[dat_p+4]),cgival, 3,"io") > 0)
			{
				printf("IO SAVE\r\n");
				for (uint8_t i=0; i<8; i++)
				{
					sprintf_P(tempbuf, PSTR("ADC%u"), i);
					save_cgivalue_if_found((char*)&(buf[dat_p+4]), tempbuf, 100+i);
				}

				for (uint8_t i=0; i<4; i++)
				{
					sprintf_P(tempbuf, PSTR("D%u"), i);
					save_cgivalue_if_found((char*)&(buf[dat_p+4]), tempbuf, 110+i);
				}

				//Reload from eeprom
				for (int i=0; i<=7; i++)
				{
					simpleSensorTypes[i] = eepromReadByte(100+i);
				}

				for (int i=0; i<=3; i++)
				{
					simpleSensorTypes[i+8] = eepromReadByte(110+i);
				}
			}

            dat_p=print_settings_io_webpage(buf);

          	goto SENDTCP;
	} else if (strncmp_P((char *)&(buf[dat_p+4]),PSTR("/settings/net"),13)==0){	
			if (!user_is_auth((char *)&(buf[dat_p+4])))
			{
				dat_p=https401();
          		goto SENDTCP;
			}

			uint8_t changed = 0;

			changed += save_cgivalue_if_found((char*)&(buf[dat_p+4]), "IP0", 11);
			changed += save_cgivalue_if_found((char*)&(buf[dat_p+4]), "IP1", 12);
			changed += save_cgivalue_if_found((char*)&(buf[dat_p+4]), "IP2", 13);
			changed += save_cgivalue_if_found((char*)&(buf[dat_p+4]), "IP3", 14);

			changed += save_cgivalue_if_found((char*)&(buf[dat_p+4]), "GW0", 15);
			changed += save_cgivalue_if_found((char*)&(buf[dat_p+4]), "GW1", 16);
			changed += save_cgivalue_if_found((char*)&(buf[dat_p+4]), "GW2", 17);
			changed += save_cgivalue_if_found((char*)&(buf[dat_p+4]), "GW3", 18);

			changed += save_cgivalue_if_found((char*)&(buf[dat_p+4]), "MASK0", 19);
			changed += save_cgivalue_if_found((char*)&(buf[dat_p+4]), "MASK1", 20);
			changed += save_cgivalue_if_found((char*)&(buf[dat_p+4]), "MASK2", 21);
			changed += save_cgivalue_if_found((char*)&(buf[dat_p+4]), "MASK3", 22);

			//23-28 MAC which is assigned dynamicly from DS2401... so not used
			//29-30 Web port, static in this firmware

			changed += save_cgivalue_if_found((char*)&(buf[dat_p+4]), "DNS0", 31);
			changed += save_cgivalue_if_found((char*)&(buf[dat_p+4]), "DNS1", 32);
			changed += save_cgivalue_if_found((char*)&(buf[dat_p+4]), "DNS2", 33);
			changed += save_cgivalue_if_found((char*)&(buf[dat_p+4]), "DNS3", 34);

			if (changed > 0) while(true);  //causes watchdog to reset the avr

            dat_p=print_settings_webpage(buf);

          	goto SENDTCP;
	} else if (strncmp_P((char *)&(buf[dat_p+4]),PSTR("/settings/alarm"),15)==0){	
			if (!user_is_auth((char *)&(buf[dat_p+4])))
			{
				dat_p=https401();
          		goto SENDTCP;
			}

			for (uint8_t i=0; i<4; i++)
			{
				char cgival[3];

				//source = 401..408
				sprintf_P(tempbuf, PSTR("S%u"), i+1);
				uint8_t length = find_key_val((char *)&(buf[dat_p+4]),cgival, 3,tempbuf);
				uint8_t sensorid = atoi(cgival);
				uint8_t loc = 0;

				if (length > 0 && sensorid < MAXSENSORS)
				{
					loc = (15*i)+1;

					for (uint8_t pos=0; pos<8; pos++)
					{
						eepromWriteByte(400+loc, sensorValues[(SENSORSIZE * sensorid) + pos]);
						loc++;
					}
				}

				if (loc > 0)
				{
					sprintf_P(tempbuf, PSTR("T%u"), i+1);
					save_cgivalue_if_found((char*)&(buf[dat_p+4]), tempbuf, 400+(15*i)+9);
					sprintf_P(tempbuf, PSTR("V%u"), i+1);
					signed_save_cgivalue_if_found((char*)&(buf[dat_p+4]), tempbuf, 400+(15*i)+10);
					sprintf_P(tempbuf, PSTR("D%u"), i+1);
					save_cgivalue_if_found((char*)&(buf[dat_p+4]), tempbuf, 400+(15*i)+11);
					sprintf_P(tempbuf, PSTR("P%u"), i+1);
					save_cgivalue_if_found((char*)&(buf[dat_p+4]), tempbuf, 400+(15*i)+12);
					sprintf_P(tempbuf, PSTR("R%u"), i+1);
					save_checkbox_cgivalue((char*)&(buf[dat_p+4]), tempbuf, 400+(15*i)+13);				
					sprintf_P(tempbuf, PSTR("E%u"), i+1);
					save_checkbox_cgivalue((char*)&(buf[dat_p+4]), tempbuf, 400+(15*i)+0);
				}
			}

			dat_p=print_flash_webpage(true, alarms_htm, buf);

          	goto SENDTCP;
	} else if (strncmp_P((char *)&(buf[dat_p+4]),PSTR("/settings/webclient"), 19)==0){
			char cgival[100];
		
			save_cgivalue_if_found((char*)&(buf[dat_p+4]), "interval", 1200);
		
			uint8_t length = find_key_val((char *)&(buf[dat_p+4]),cgival, 99,"host");
			if (length > 0 && length <= 99)
			{
				urldecode(cgival);
				cgival[strlen(cgival)] = '\0';
				eepromSaveStr(1000, cgival, strlen(cgival)+1);
				dns_state = 0;
				printf("Host changed to %s ", cgival);
			}

			length = find_key_val((char *)&(buf[dat_p+4]),cgival, 99,"url");
			if (length > 0 && length <= 99)
			{
				eepromSaveByte(1100, '/');
				urldecode(cgival);
				cgival[strlen(cgival)] = '\0';
				eepromSaveStr(1101, cgival, strlen(cgival)+1);
				printf("URL changed to %s ", cgival);
			}
		
			dat_p=print_webclient_webpage(buf);
			goto SENDTCP;			  
	} else if (strncmp_P((char *)&(buf[dat_p+4]),PSTR("/fmu.js"), 7)==0){	
			dat_p=print_flash_webpage(true, fmu_js, buf);

          	goto SENDTCP;
    } else if (strncmp_P((char *)&(buf[dat_p+4]),PSTR("/fmu2.js"),8)==0){	
            dat_p=print_flash_webpage(true, fmu2_js, buf);

          	goto SENDTCP;
    } else if (strncmp_P((char *)&(buf[dat_p+4]),PSTR("/alarms.js"),10)==0){	
            dat_p=print_flash_webpage(true, alarms_js, buf);

          	goto SENDTCP;
    } else if (strncmp_P((char *)&(buf[dat_p+4]),PSTR("/loader.js"),10)==0){	
            dat_p=print_flash_webpage(true, loader_js, buf);

          	goto SENDTCP;
    } else if (strncmp_P((char *)&(buf[dat_p+4]),PSTR("/slist.js"),9)==0){	
            dat_p=print_sensorlist(buf);

          	goto SENDTCP;
    } else if (strncmp_P((char *)&(buf[dat_p+4]),PSTR("/alist.js"),9)==0){	
            dat_p=print_alarmlist(buf);

          	goto SENDTCP;
    } else if (strncmp_P((char *)&(buf[dat_p+4]),PSTR("/style.css"),10)==0){	
            dat_p=print_flash_webpage(true, style_css, buf);
          	goto SENDTCP;		
    } else if (strncmp_P((char *)&(buf[dat_p+4]),PSTR("/export.htm"),11)==0){	
            dat_p=print_export_htm(buf);

          	goto SENDTCP;
    } else{
            dat_p=fill_tcp_data_p(buf,0,PSTR("HTTP/1.0 401 Unauthorized\r\nContent-Type: text/html\r\n\r\n<h1>401 Unauthorized</h1>"));
            goto SENDTCP;
    }
    //

	SENDTCP:
    www_server_reply(buf,dat_p); // send data
}

bool save_checkbox_cgivalue(char* buffer, char* name, uint16_t eeprom_location)
{
	char cgival[11];
	uint8_t length = 0;
	length = find_key_val(buffer,cgival, 10,name);
	uint8_t value = 0;

	if (length > 0)
	{
		cgival[length+1] = '\0';
		value = atoi(cgival);
		eepromWriteByte(eeprom_location, value);
		printf("Write %u at %u \r\n", value, eeprom_location);
		return true;
	} else { 
		printf("Write 0 at %u \r\n", eeprom_location);
		eepromWriteByte(eeprom_location, 0);
		return false;
	}
}

bool save_cgivalue_if_found(char* buffer, char* name, uint16_t eeprom_location)
{
	char cgival[11];
	uint8_t length = 0;
	length = find_key_val(buffer,cgival, 10,name);
	uint8_t value = 0;

	if (length > 0)
	{
		cgival[length+1] = '\0';
		value = atoi(cgival);
		eepromWriteByte(eeprom_location, value);
		return true;
	}

	return false;
}

bool signed_save_cgivalue_if_found(char* buffer, char* name, uint16_t eeprom_location)
{
	char cgival[11];
	uint8_t length = 0;
	length = find_key_val(buffer,cgival, 10,name);
	int8_t value = 0;

	if (length > 0)
	{
		cgival[length+1] = '\0';
		value = atoi(cgival);
		eepromWriteByte(eeprom_location, value);
		return true;
	}

	return false;
}

void lcd_callback(uint8_t statuscode,uint16_t datapos, uint16_t len){
		printf_P(PSTR("got lcd reply ...\r\n"));
        //datapos=0; // supress warning about unused paramter
		start_web_client=0;
        if (statuscode==0){
                //len=0; // avoid warning about unused variable
				char* buffer = (char *)&(buf[datapos]);
				char* datapos = strstr(buffer, "\r\n\r\n");
				datapos += 4;
				printf("Data : %s \r\n", datapos);

				while (datapos != NULL)
				{
					if (datapos[0] == '\n')
						datapos++;

					char crc[6];
					strncpy(crc, datapos+86, 5);
					crc[5] = '\0';
					printf("CRC IS %s \r\n", crc);

					uint16_t crci = atoi(crc);
					uint16_t crcc = 0;
					for (uint8_t i=0; i<84; i++)
					{
						crcc += datapos[i+1];
					}
					printf("Calculated crc is %u \r\n", crcc);
					if (crcc == crci)
					{
						uint8_t screenno = datapos[0] - 48;
						printf("LCD crc for screen %c (%u) is valid \r\n", datapos[0], screenno);
						

						char stimeout[5];
						strncpy(stimeout, (datapos+1), 4);
						stimeout[4] = '\0';
						printf("Timeout is %s \r\n", stimeout);
						lcd_timeouts[screenno] = atoi(stimeout);
						printf("Set timeout for %u to %u \r\n", screenno, lcd_timeouts[screenno]);

						uint16_t linepos = 5;
						for (uint8_t lineno=0; lineno<4; lineno++)
						{
							for (uint8_t c=0; c<20; c++)
							{
								lines[screenno][lineno][c] = datapos[linepos++];
							}
							lines[screenno][lineno][20] = '\0';
						}

						if (lcd_current_screen == 254)	//waiting for data
							lcd_current_screen = 250;
					}

					datapos++;
					datapos = strstr(datapos, "\n");
					printf("Strlen is %u \r\n", strlen(datapos));
					if (strlen(datapos) < 80) break;
				}
		}
}

//Her skal vi håndtere svaret fra stokerlog, der kan komme SET PIN STATE, LCD LINE TEXT, TIME DDMMYY HHMMSS
void browserresult_callback(uint8_t statuscode,uint16_t datapos, uint16_t len){
		printf_P(PSTR("got reply %u ...\r\n"),statuscode);
        //datapos=0; // supress warning about unused paramter
		start_web_client=0;
        if (statuscode==0){
                //len=0; // avoid warning about unused variable
				printf("Datapos %u len %u \r\n", datapos, len);
				char* buffer = (char *)&(buf[datapos]);
				printf("%s \r\n\r\nEND\r\n", buffer);
				char* datapos = strstr(buffer, "\r\n\r\n");
				datapos += 4;
				printf("Data : %s \r\n", datapos);

/*
HTTP/1.0 200 OK
Date: Thu, 05 May 2011 18:04:16 GMT
Server: Apache
Connection: close
Content-Type: text/html; charset=utf-8

EOM 

END
Data : EOM 
*/
//For each line, parse contents

//This is a safety measure, to prevent the bot from running a bad event when rebooted, events time out after 5minutes
//if (uptime > 300) {
			char* line = strstr(buffer, "RIO");
			while (line != NULL)
			{
				unsigned int id, pin, state, delay;
				printf("RAW %s \r\n", line);
				sscanf(line, "RIO %u %u %u %u", &id, &pin, &state, &delay);
				printf("Found RIO line id:%u pin:%u state:%u delay:%u \r\n",id,pin,state,delay);
				printf("Last event is %lu \r\n", last_rio_event);
				if (id <= last_rio_event)
				{
					printf("Repeated RIO event detected \r\n");
				} else {
					#if SBNG_TARGET == 50
					if (pin > 20)
					{
						simpleSensorValues[pin] = state;
					} else {
					#endif
						if (state == 1)
							SETBIT(PORTC, (2+pin));
						else
							CLEARBIT(PORTC, (2+pin));
					#if SBNG_TARGET == 50
					}
					#endif
					if (delay != 0)
						addTimedEvent(id, pin, state, delay);

					last_rio_event=id;
				}

				line = strstr(line, "\n");
				line = strstr(line, "RIO");
			}
//}

                web_client_sendok++;
				web_client_monitor=0;
        }
}
